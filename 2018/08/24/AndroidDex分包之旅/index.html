<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="当程序越来越大之后，出现了一个 dex 包装不下的情况，通过 MultiDex 的方法解决了这个问题，但是在底端机器上又出现了 INSTALL_FAILED_DEXOPT 的情况，那再解决这个问题吧。等解决完这个问题之后，发现需要填的坑越来越多了，文章讲的是我在分包处理中填的坑，比如 65536、LinearAlloc、NoClassDefFoundError等等。 INSTALL_FAILED_">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Dex分包之旅">
<meta property="og:url" content="http://yoursite.com/2018/08/24/AndroidDex分包之旅/index.html">
<meta property="og:site_name" content="Mikee的八度空间">
<meta property="og:description" content="当程序越来越大之后，出现了一个 dex 包装不下的情况，通过 MultiDex 的方法解决了这个问题，但是在底端机器上又出现了 INSTALL_FAILED_DEXOPT 的情况，那再解决这个问题吧。等解决完这个问题之后，发现需要填的坑越来越多了，文章讲的是我在分包处理中填的坑，比如 65536、LinearAlloc、NoClassDefFoundError等等。 INSTALL_FAILED_">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-11T08:14:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Dex分包之旅">
<meta name="twitter:description" content="当程序越来越大之后，出现了一个 dex 包装不下的情况，通过 MultiDex 的方法解决了这个问题，但是在底端机器上又出现了 INSTALL_FAILED_DEXOPT 的情况，那再解决这个问题吧。等解决完这个问题之后，发现需要填的坑越来越多了，文章讲的是我在分包处理中填的坑，比如 65536、LinearAlloc、NoClassDefFoundError等等。 INSTALL_FAILED_">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Android Dex分包之旅 | Mikee的八度空间 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mikee的八度空间</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android Dex分包之旅
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-08-24T11:40:00+08:00" content="2018-08-24">
              2018-08-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>当程序越来越大之后，出现了一个 dex 包装不下的情况，通过 MultiDex 的方法解决了这个问题，但是在底端机器上又出现了 INSTALL_FAILED_DEXOPT 的情况，那再解决这个问题吧。等解决完这个问题之后，发现需要填的坑越来越多了，文章讲的是我在分包处理中填的坑，比如 65536、LinearAlloc、NoClassDefFoundError等等。</p>
<h2 id="INSTALL-FAILED-DEXOPT"><a href="#INSTALL-FAILED-DEXOPT" class="headerlink" title="INSTALL_FAILED_DEXOPT"></a>INSTALL_FAILED_DEXOPT</h2><p>INSTALL_FAILED_DEXOPT 出现的原因大部分都是两种，一种是 65536 了，另外一种是 LinearAlloc 太小了。两者的限制不同，但是原因却是相似，那就是App太大了，导致没办法安装到手机上。</p>
<h2 id="65536"><a href="#65536" class="headerlink" title="65536"></a>65536</h2><p>trouble writing output: Too many method references: 70048; max is 65536.<br>或者<br>UNEXPECTED TOP-LEVEL EXCEPTION:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: method ID not in [0, 0xffff]: 65536</span><br><span class="line">​ at com.android.dx.merge.DexMerger$6.updateIndex(DexMerger.java:501)</span><br><span class="line">​ at com.android.dx.merge.DexMerger$IdMerger.mergeSorted(DexMerger.java:276)</span><br><span class="line">​ at com.android.dx.merge.DexMerger.mergeMethodIds(DexMerger.java:490)</span><br><span class="line">​ at com.android.dx.merge.DexMerger.mergeDexes(DexMerger.java:167)</span><br><span class="line">​ at com.android.dx.merge.DexMerger.merge(DexMerger.java:188)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.mergeLibraryDexBuffers(Main.java:439)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.runMonoDex(Main.java:287)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.run(Main.java:230)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.main(Main.java:199)</span><br><span class="line">​ at com.android.dx.command.Main.main(Main.java:103):Derp:dexDerpDebug FAILED</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">编译环境</span><br><span class="line">``` </span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:1.3.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;25.0.3&quot;</span><br><span class="line">	//....</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 14</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">#### 为什么是65536</span><br><span class="line">根据 StackOverFlow – Does the Android ART runtime have the same method limit limitations as Dalvik? 上面的说法，是因为 Dalvik 的 invoke-kind 指令集中，method reference index 只留了 16 bits，最多能引用 65535 个方法。Dalvik bytecode ：</span><br><span class="line"></span><br><span class="line">| Op &amp; Format	Mnemonic      |    Mnemonic / Syntax | Arguments  |</span><br><span class="line">| :-------- | --------:| :--: |</span><br><span class="line">| 6e..72   | invoke-kind &#123;vC, vD, vE, vF, vG&#125;, meth@BBBB6e:  |  A: argument word count (4 bits)B:   |</span><br><span class="line">| 35c     |   invoke-virtual6f: invoke-super70: invoke-direct71: invoke-static72: invoke-interface |  method reference index (16 bits)C..G: argument registers (4 bits each)  |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 即使 dex 里面的引用方法数超过了 65536，那也只有前面的 65536 得的到调用。所以这个不是 dex 的原因。其次，既然和 dex 没有关系，那在打包 dex 的时候为什么会报错。我们先定位 Too many 关键字，定位到了 MemberIdsSection ：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public abstract class MemberIdsSection extends UniformItemSection &#123;</span><br><span class="line">  /** &#123;@inheritDoc&#125; */</span><br><span class="line">    @Override</span><br><span class="line">    protected void orderItems() &#123;</span><br><span class="line">        int idx = 0;</span><br><span class="line"></span><br><span class="line">        if (items().size() &gt; DexFormat.MAX_MEMBER_IDX + 1) &#123;</span><br><span class="line">            throw new DexIndexOverflowException(getTooManyMembersMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Object i : items()) &#123;</span><br><span class="line">            ((MemberIdItem) i).setIndex(idx);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getTooManyMembersMessage() &#123;</span><br><span class="line">        Map&lt;String, AtomicInteger&gt; membersByPackage = new TreeMap&lt;String, AtomicInteger&gt;();</span><br><span class="line">        for (Object member : items()) &#123;</span><br><span class="line">            String packageName = ((MemberIdItem) member).getDefiningClass().getPackageName();</span><br><span class="line">            AtomicInteger count = membersByPackage.get(packageName);</span><br><span class="line">            if (count == null) &#123;</span><br><span class="line">                count = new AtomicInteger();</span><br><span class="line">                membersByPackage.put(packageName, count);</span><br><span class="line">            &#125;</span><br><span class="line">            count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Formatter formatter = new Formatter();</span><br><span class="line">        try &#123;</span><br><span class="line">            String memberType = this instanceof MethodIdsSection ? &quot;method&quot; : &quot;field&quot;;</span><br><span class="line">            formatter.format(&quot;Too many %s references: %d; max is %d.%n&quot; +</span><br><span class="line">                    Main.getTooManyIdsErrorMessage() + &quot;%n&quot; +</span><br><span class="line">                    &quot;References by package:&quot;,</span><br><span class="line">                    memberType, items().size(), DexFormat.MAX_MEMBER_IDX + 1);</span><br><span class="line">            for (Map.Entry&lt;String, AtomicInteger&gt; entry : membersByPackage.entrySet()) &#123;</span><br><span class="line">                formatter.format(&quot;%n%6d %s&quot;, entry.getValue().get(), entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">            return formatter.toString();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            formatter.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">items().size() &gt; DexFormat.MAX_MEMBER_IDX + 1 ，那 DexFormat 的值是：</span><br><span class="line">``` </span><br><span class="line">public final class DexFormat &#123;</span><br><span class="line">  /**</span><br><span class="line">     * Maximum addressable field or method index.</span><br><span class="line">     * The largest addressable member is 0xffff, in the &quot;instruction formats&quot; spec as field@CCCC or</span><br><span class="line">     * meth@CCCC.</span><br><span class="line">     */</span><br><span class="line">    public static final int MAX_MEMBER_IDX = 0xFFFF;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">dx 在这里做了判断，当大于 65536 的时候就抛出异常了。所以在生成 dex 文件的过程中，当调用方法数不能超过 65535 。那我们再跟一跟代码，发现 MemberIdsSection 的一个子类叫 MethodidsSection ：</span><br><span class="line">``` </span><br><span class="line">public final class MethodIdsSection extends MemberIdsSection &#123;&#125;</span><br><span class="line">``` </span><br><span class="line">回过头来，看一下 orderItems() 方法在哪里被调用了，跟到了 MemberIdsSection 的父类 UniformItemSection :</span><br><span class="line">``` </span><br><span class="line">public abstract class UniformItemSection extends Section &#123;</span><br><span class="line">	@Override</span><br><span class="line">    protected final void prepare0() &#123;</span><br><span class="line">        DexFile file = getFile();</span><br><span class="line"></span><br><span class="line">        orderItems();</span><br><span class="line"></span><br><span class="line">        for (Item one : items()) &#123;</span><br><span class="line">            one.addContents(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">	protected abstract void orderItems();</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">再跟一下 prepare0 在哪里被调用，查到了 UniformItemSection 父类 Section :</span><br><span class="line">``` </span><br><span class="line">public abstract class Section &#123;</span><br><span class="line">	public final void prepare() &#123;</span><br><span class="line">        throwIfPrepared();</span><br><span class="line">        prepare0();</span><br><span class="line">        prepared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	protected abstract void prepare0();</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">那现在再跟一下 prepare() ，查到 DexFile 中有调用：</span><br><span class="line">``` </span><br><span class="line">public final class DexFile &#123;</span><br><span class="line">  private ByteArrayAnnotatedOutput toDex0(boolean annotate, boolean verbose) &#123;</span><br><span class="line">        classDefs.prepare();</span><br><span class="line">        classData.prepare();</span><br><span class="line">        wordData.prepare();</span><br><span class="line">        byteData.prepare();</span><br><span class="line">        methodIds.prepare();</span><br><span class="line">        fieldIds.prepare();</span><br><span class="line">        protoIds.prepare();</span><br><span class="line">        typeLists.prepare();</span><br><span class="line">        typeIds.prepare();</span><br><span class="line">        stringIds.prepare();</span><br><span class="line">        stringData.prepare();</span><br><span class="line">        header.prepare();</span><br><span class="line">		//blablabla......</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">那再看一下 toDex0() 吧，因为是 private 的，直接在类中找调用的地方就可以了：</span><br><span class="line">``` </span><br><span class="line">public final class DexFile &#123;</span><br><span class="line">	public byte[] toDex(Writer humanOut, boolean verbose) throws IOException &#123;</span><br><span class="line">        boolean annotate = (humanOut != null);</span><br><span class="line">        ByteArrayAnnotatedOutput result = toDex0(annotate, verbose);</span><br><span class="line"></span><br><span class="line">        if (annotate) &#123;</span><br><span class="line">            result.writeAnnotationsTo(humanOut);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.getArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	public void writeTo(OutputStream out, Writer humanOut, boolean verbose) throws IOException &#123;</span><br><span class="line">        boolean annotate = (humanOut != null);</span><br><span class="line">        ByteArrayAnnotatedOutput result = toDex0(annotate, verbose);</span><br><span class="line"></span><br><span class="line">        if (out != null) &#123;</span><br><span class="line">            out.write(result.getArray());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (annotate) &#123;</span><br><span class="line">            result.writeAnnotationsTo(humanOut);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">先搜搜 toDex() 方法吧，最终发现在 com.android.dx.command.dexer.Main 中：</span><br><span class="line">``` </span><br><span class="line">public class Main &#123;</span><br><span class="line">	private static byte[] writeDex(DexFile outputDex) &#123;</span><br><span class="line">        byte[] outArray = null;</span><br><span class="line">      	//blablabla......</span><br><span class="line">		if (args.methodToDump != null) &#123;</span><br><span class="line">			outputDex.toDex(null, false);</span><br><span class="line">            dumpMethod(outputDex, args.methodToDump, humanOutWriter);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			outArray = outputDex.toDex(humanOutWriter, args.verboseDump);</span><br><span class="line">		&#125;</span><br><span class="line">		//blablabla......</span><br><span class="line">        return outArray;</span><br><span class="line">    &#125;</span><br><span class="line">  	//调用writeDex的地方</span><br><span class="line">  	private static int runMonoDex() throws IOException &#123;</span><br><span class="line">  		//blablabla......</span><br><span class="line">      	outArray = writeDex(outputDex);</span><br><span class="line">      	//blablabla......</span><br><span class="line">	&#125;</span><br><span class="line">  	//调用runMonoDex的地方</span><br><span class="line">  	public static int run(Arguments arguments) throws IOException &#123;</span><br><span class="line">  		if (args.multiDex) &#123;</span><br><span class="line">			return runMultiDex();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">            return runMonoDex();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">args.multiDex 就是是否分包的参数，那么问题找着了，如果不选择分包的情况下，引用方法数超过了 65536 的话就会抛出异常。</span><br><span class="line"></span><br><span class="line">同样分析第二种情况，根据错误信息可以具体定位到代码，但是很奇怪的是 DexMerger ，我们没有设置分包参数或者其他参数，为什么会有 DexMerger ，而且依赖工程最终不都是 aar 格式的吗？那我们还是来跟一跟代码吧。</span><br><span class="line">``` </span><br><span class="line">public class Main &#123;</span><br><span class="line">	private static byte[] mergeLibraryDexBuffers(byte[] outArray) throws IOException &#123;</span><br><span class="line">        ArrayList&lt;Dex&gt; dexes = new ArrayList&lt;Dex&gt;();</span><br><span class="line">        if (outArray != null) &#123;</span><br><span class="line">            dexes.add(new Dex(outArray));</span><br><span class="line">        &#125;</span><br><span class="line">        for (byte[] libraryDex : libraryDexBuffers) &#123;</span><br><span class="line">            dexes.add(new Dex(libraryDex));</span><br><span class="line">        &#125;</span><br><span class="line">        if (dexes.isEmpty()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Dex merged = new DexMerger(dexes.toArray(new Dex[dexes.size()]), CollisionPolicy.FAIL).merge();</span><br><span class="line">        return merged.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">这里可以看到变量 libraryDexBuffers ，是一个 List 集合，那么我们看一下这个集合在哪里添加数据的：</span><br><span class="line">``` </span><br><span class="line">public class Main &#123;</span><br><span class="line">	private static boolean processFileBytes(String name, long lastModified, byte[] bytes) &#123;</span><br><span class="line">  		boolean isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);</span><br><span class="line">      	//blablabla...</span><br><span class="line">        &#125; else if (isClassesDex) &#123;</span><br><span class="line">            synchronized (libraryDexBuffers) &#123;</span><br><span class="line">                libraryDexBuffers.add(bytes);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">	&#125;</span><br><span class="line">  	//调用processFileBytes的地方</span><br><span class="line">  	private static class FileBytesConsumer implements ClassPathOpener.Consumer &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean processFileBytes(String name, long lastModified,</span><br><span class="line">                byte[] bytes)   &#123;</span><br><span class="line">            return Main.processFileBytes(name, lastModified, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">      	//blablabla...</span><br><span class="line">    &#125;</span><br><span class="line">  	//调用FileBytesConsumer的地方</span><br><span class="line">  	private static void processOne(String pathname, FileNameFilter filter) &#123;</span><br><span class="line">        ClassPathOpener opener;</span><br><span class="line"></span><br><span class="line">        opener = new ClassPathOpener(pathname, true, filter, new FileBytesConsumer());</span><br><span class="line"></span><br><span class="line">        if (opener.process()) &#123;</span><br><span class="line">          updateStatus(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	//调用processOne的地方</span><br><span class="line">  	private static boolean processAllFiles() &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">  		// forced in main dex</span><br><span class="line">        for (int i = 0; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">			processOne(fileNames[i], mainPassFilter);</span><br><span class="line">		&#125;</span><br><span class="line">      	//blablabla...</span><br><span class="line">	&#125;</span><br><span class="line">  	//调用processAllFiles的地方</span><br><span class="line">  	private static int runMonoDex() throws IOException &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">  		if (!processAllFiles()) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">      	//blablabla...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">跟了一圈又跟回来了，但是注意一个变量：fileNames[i]，传进去这个变量，是个地址，最终在 processFileBytes 中处理后添加到 libraryDexBuffers 中，那跟一下这个变量：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class Main &#123;</span><br><span class="line">  	private static boolean processAllFiles() &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">  		String[] fileNames = args.fileNames;</span><br><span class="line">      	//blablabla...</span><br><span class="line">	&#125;</span><br><span class="line">  	public void parse(String[] args) &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">    	&#125;else if(parser.isArg(INPUT_LIST_OPTION + &quot;=&quot;)) &#123;</span><br><span class="line">			File inputListFile = new File(parser.getLastValue());</span><br><span class="line">			try&#123;</span><br><span class="line">				inputList = new ArrayList&lt;String&gt;();</span><br><span class="line">                readPathsFromFile(inputListFile.getAbsolutePath(), inputList);</span><br><span class="line">            &#125; catch(IOException e) &#123;</span><br><span class="line">				System.err.println(&quot;Unable to read input list file: &quot; + inputListFile.getName());</span><br><span class="line">				throw new UsageException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">      	//blablabla...</span><br><span class="line">  		fileNames = parser.getRemaining();</span><br><span class="line">		if(inputList != null &amp;&amp; !inputList.isEmpty()) &#123;</span><br><span class="line">            inputList.addAll(Arrays.asList(fileNames));</span><br><span class="line">            fileNames = inputList.toArray(new String[inputList.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">  	public static void main(String[] argArray) throws IOException &#123;</span><br><span class="line">        Arguments arguments = new Arguments();</span><br><span class="line">        arguments.parse(argArray);</span><br><span class="line"></span><br><span class="line">        int result = run(arguments);</span><br><span class="line">        if (result != 0) &#123;</span><br><span class="line">            System.exit(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">跟到这里发现是传进来的参数，那我们再看看 gradle 里面传的是什么参数吧，查看 Dex task :</span><br><span class="line">``` </span><br><span class="line">public class Dex extends BaseTask &#123;</span><br><span class="line">  	@InputFiles</span><br><span class="line">    Collection&lt;File&gt; libraries</span><br><span class="line">&#125;</span><br><span class="line">我们把这个参数打印出来：</span><br><span class="line"></span><br><span class="line">afterEvaluate &#123;</span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(&apos;dex&apos;)</span><br><span class="line">    &#125;.each &#123; dx -&gt;</span><br><span class="line">        if (dx.additionalParameters == null) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        println dx.libraries</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">打印出来发现是 build/intermediates/pre-dexed/ 目录里面的 jar 文件，再把 jar 文件解压发现里面就是 dex 文件了。所以 DexMerger 的工作就是合并这里的 dex 。</span><br><span class="line"></span><br><span class="line">更改编译环境</span><br><span class="line">``` </span><br><span class="line">buildscript &#123;</span><br><span class="line">	//...</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:2.1.0-alpha3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">将 gradle 设置为 2.1.0-alpha3 之后，在项目的 build.gradle 中即使没有设置 multiDexEnabled true 也能够编译通过，但是生成的 apk 包依旧是两个 dex ，我想的是可能为了设置 instantRun 。</span><br><span class="line"></span><br><span class="line">#### 解决 65536</span><br><span class="line"></span><br><span class="line">Google MultiDex 解决方案：</span><br><span class="line"></span><br><span class="line">在 gradle 中添加 MultiDex 的依赖：</span><br><span class="line">``` </span><br><span class="line">dependencies &#123; compile &apos;com.android.support:MultiDex:1.0.0&apos; &#125;</span><br><span class="line">``` </span><br><span class="line">在 gradle 中配置 MultiDexEnable :</span><br><span class="line">``` </span><br><span class="line">android &#123;</span><br><span class="line">	buildToolsVersion &quot;21.1.0&quot;</span><br><span class="line">	defaultConfig &#123;</span><br><span class="line">        // Enabling MultiDex support.</span><br><span class="line">        MultiDexEnabled true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">在 AndroidManifest.xml 的 application 中声明:</span><br><span class="line">``` </span><br><span class="line">&lt;application</span><br><span class="line">  android:name=&quot;android.support.multidex.MultiDexApplication&quot;&gt;</span><br><span class="line">&lt;application/&gt;</span><br><span class="line">``` </span><br><span class="line">如果有自己的 Application 了，让其继承于 MultiDexApplication 。</span><br><span class="line"></span><br><span class="line">如果继承了其他的 Application ，那么可以重写 attachBaseContext(Context):</span><br><span class="line">``` </span><br><span class="line">@Override </span><br><span class="line">protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">    MultiDex.install(this);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## LinearAlloc</span><br><span class="line">gradle：</span><br></pre></td></tr></table></figure></p>
<p>afterEvaluate {<br>  tasks.matching {<br>    it.name.startsWith(‘dex’)<br>  }.each { dx -&gt;<br>    if (dx.additionalParameters == null) {<br>      dx.additionalParameters = []<br>    }<br>    dx.additionalParameters += ‘–set-max-idx-number=48000’<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--set-max-idx-number= 用于控制每一个 dex 的最大方法个数。</span><br><span class="line"></span><br><span class="line">这个参数在查看 dx.jar 找到：</span><br></pre></td></tr></table></figure></p>
<p>//blablabla…<br>} else if (parser.isArg(“–set-max-idx-number=”)) { // undocumented test option<br>  maxNumberOfIdxPerDex = Integer.parseInt(parser.getLastValue());<br>} else if(parser.isArg(INPUT_LIST_OPTION + “=”)) {<br>//blablabla…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">更多细节可以查看源码：Github – platform_dalvik/Main</span><br><span class="line"></span><br><span class="line">FB 的工程师们曾经还想到过直接修改 LinearAlloc 的大小，比如从 5M 修改到 8M： Under the Hood: Dalvik patch for Facebook for Android 。</span><br><span class="line"></span><br><span class="line">## dexopt &amp;&amp; dex2oat</span><br><span class="line">![](media/15350820002263/15350900382484.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## dexopt</span><br><span class="line">当 Android 系统安装一个应用的时候，有一步是对 Dex 进行优化，这个过程有一个专门的工具来处理，叫 DexOpt。DexOpt 是在第一次加载 Dex 文件的时候执行的，将 dex 的依赖库文件和一些辅助数据打包成 odex 文件，即 Optimised Dex，存放在 cache/dalvik_cache 目录下。保存格式为 apk路径 @ apk名 @ classes.dex 。执行 ODEX 的效率会比直接执行 Dex 文件的效率要高很多。</span><br><span class="line"></span><br><span class="line">## dex2oat</span><br><span class="line">Android Runtime 的 dex2oat 是将 dex 文件编译成 oat 文件。而 oat 文件是 elf 文件，是可以在本地执行的文件，而 Android Runtime 替换掉了虚拟机读取的字节码转而用本地可执行代码，这就被叫做 AOT(ahead-of-time)。dex2oat 对所有 apk 进行编译并保存在 dalvik-cache 目录里。PackageManagerService 会持续扫描安装目录，如果有新的 App 安装则马上调用 dex2oat 进行编译。</span><br><span class="line"></span><br><span class="line">## NoClassDefFoundError</span><br><span class="line">现在 INSTALL_FAILED_DEXOPT 问题是解决了，但是有时候编译完运行的时候一打开 App 就 crash 了，查看 log 发现是某个类找不到引用。</span><br><span class="line"></span><br><span class="line">- Build Tool 是如何分包的</span><br><span class="line">为什么会这样呢？是因为 build-tool 在分包的时候只判断了直接引用类。什么是直接引用类呢？举个栗子：</span><br></pre></td></tr></table></figure></p>
<p>public class MainActivity extends Activity {<br>    protected void onCreate(Bundle savedInstanceState) {<br>        DirectReferenceClass test = new DirectReferenceClass();<br>    }<br>}</p>
<p>public class DirectReferenceClass {<br>    public DirectReferenceClass() {<br>        InDirectReferenceClass test = new InDirectReferenceClass();<br>    }<br>}</p>
<p>public class InDirectReferenceClass {<br>    public InDirectReferenceClass() {</p>
<pre><code>}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面有 MainActivity、DirectReferenceClass 、InDirectReferenceClass 三个类，其中 DirectReferenceClass 是 MainActivity 的直接引用类，InDirectReferenceClass 是 DirectReferenceClass 的直接引用类。而 InDirectReferenceClass 是 MainActivity 的间接引用类(即直接引用类的所有直接引用类)。</span><br><span class="line"></span><br><span class="line">如果我们代码是这样写的：</span><br></pre></td></tr></table></figure></p>
<p>public class HelloMultiDexApplication extends Application {<br>    @Override<br>    protected void attachBaseContext(Context base) {<br>        super.attachBaseContext(base);<br>        DirectReferenceClass test = new DirectReferenceClass();<br>        MultiDex.install(this);<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这样直接就 crash 了。同理还要单例模式中拿到单例之后直接调用某个方法返回的是另外一个对象，并非单例对象。</span><br><span class="line"></span><br><span class="line">build tool 的分包操作可以查看 sdk 中 build-tools 文件夹下的 mainDexClasses 脚本，同时还发现了 mainDexClasses.rules 文件，该文件是主 dex 的匹配规则。该脚本要求输入一个文件组（包含编译后的目录或jar包），然后分析文件组中的类并写入到–output所指定的文件中。实现原理也不复杂，主要分为三步：</span><br><span class="line"></span><br><span class="line">- 环境检查，包括传入参数合法性检查，路径检查以及proguard环境检测等。</span><br><span class="line">- 使用mainDexClasses.rules规则，通过Proguard的shrink功能，裁剪无关类，生成一个tmp.jar包。</span><br><span class="line">- 通过生成的tmp jar包，调用MainDexListBuilder类生成主dex的文件列表</span><br><span class="line"></span><br><span class="line">## Gradle 打包流程中是如何分包的</span><br><span class="line">在项目中，可以直接运行 gradle 的 task 。</span><br><span class="line">- **collect&#123;flavor&#125;&#123;buildType&#125;MultiDexComponents** Task 。这个 task 是获取 AndroidManifest.xml 中 Application 、Activity 、Service 、 Receiver 、 Provider 等相关类，以及 Annotation ，之后将内容写到 **build/intermediates/multi-dex/&#123;flavor&#125;/&#123;buildType&#125;/maindexlist.txt** 文件中去。</span><br><span class="line"></span><br><span class="line">- **packageAll&#123;flavor&#125;DebugClassesForMultiDex** Task 。该 task 是将所有类打包成 jar 文件存在 **build/intermediates/multi-dex/&#123;flavor&#125;/debug/allclasses.jar** 。 当 BuildType 为 Release 的时候，执行的是 proguard&#123;flavor&#125;Release Task，该 task 将 proguard 混淆后的类打包成 jar 文件存在 **build/intermediates/classes-proguard/&#123;flavor&#125;/release/classes.jar**</span><br><span class="line"></span><br><span class="line">- **shrink&#123;flavor&#125;&#123;buildType&#125;MultiDexComponents** Task 。该 task 会根据 maindexlist.txt 生成 componentClasses.jar ，该 jar 包里面就只有 maindexlist.txt 里面的类，该 jar 包的位置在 **build/intermediates/multi-dex/&#123;flavor&#125;/&#123;buildType&#125;/componentClasses.jar**</span><br><span class="line"></span><br><span class="line">- **create&#123;flavor&#125;&#123;buildType&#125;MainDexClassList** Task 。该 task 会根据生成的 componentClasses.jar 去找这里面的所有的 class 中直接依赖的 class ，然后将内容写到 **build/intermediates/multi-dex/&#123;flavor&#125;/&#123;buildType&#125;/maindexlist.txt** 中。最终这个文件里面列出来的类都会被分配到第一个 dex 里面。</span><br><span class="line"></span><br><span class="line">## 解决 NoClassDefFoundError</span><br><span class="line">gradle :</span><br></pre></td></tr></table></figure></p>
<p>afterEvaluate {<br>  tasks.matching {<br>    it.name.startsWith(‘dex’)<br>  }.each { dx -&gt;<br>    if (dx.additionalParameters == null) {<br>      dx.additionalParameters = []<br>    }<br>    dx.additionalParameters += ‘–set-max-idx-number=48000’<br>    dx.additionalParameters += “–main-dex-list=$projectDir/multidex.keep”.toString()<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">**--main-dex-list=** 参数是一个类列表的文件，在该文件中的类会被打包在第一个 dex 中。</span><br><span class="line"></span><br><span class="line">multidex.keep 里面列上需要打包到第一个 dex 的 class 文件，注意，如果需要混淆的话需要写混淆之后的 class 。</span><br><span class="line"></span><br><span class="line">## Application Not Responding</span><br><span class="line">因为第一次运行（包括清除数据之后）的时候需要 dexopt ，然而 dexopt 是一个比较耗时的操作，同时 MultiDex.install() 操作是在 Application.attachBaseContext() 中进行的，占用的是UI线程。那么问题来了，当我的第二个包、第三个包很大的时候，程序就阻塞在 MultiDex.install() 这个地方了，一旦超过规定时间，那就 ANR 了。那怎么办？放子线程？如果 Application 有一些初始化操作，到初始化操作的地方的时候都还没有完成 install + dexopt 的话，那不是又 NoClassDefFoundError 了吗？同时 ClassLoader 放在哪个线程都让主线程挂起。好了，那在 multidex.keep 的加上相关的所有的类吧。好像这样成了，但是第一个 dex 又大起来了，而且如果用户操作快，还没完成 install + dexopt 但是已经把 App 所以界面都打开了一遍。。。虽然这不现实。。</span><br><span class="line"># 微信加载方案</span><br><span class="line">首次加载在地球中页中, 并用线程去加载（但是 5.0 之前加载 dex 时还是会挂起主线程一段时间（不是全程都挂起））。</span><br><span class="line">- dex 形式</span><br><span class="line"> 微信是将包放在 assets 目录下的，在加载 Dex 的代码时，实际上传进去的是 zip，在加载前需要验证 MD5，确保所加载的 Dex 没有被篡改。</span><br><span class="line"> </span><br><span class="line">- dex 类分包规则</span><br><span class="line">分包规则即将所有 Application、ContentProvider 以及所有 export 的 Activity、Service 、Receiver 的间接依赖集都必须放在主 dex。</span><br><span class="line"></span><br><span class="line">- 加载 dex 的方式</span><br><span class="line">加载逻辑这边主要判断是否已经 dexopt，若已经 dexopt，即放在 attachBaseContext 加载，反之放于地球中用线程加载。怎么判断？因为在微信中，若判断 revision 改变，即将 dex 以及 dexopt 目录清空。只需简单判断两个目录 dex 名称、数量是否与配置文件的一致。</span><br><span class="line"></span><br><span class="line">总的来说，这种方案用户体验较好，缺点在于太过复杂，每次都需重新扫描依赖集，而且使用的是比较大的间接依赖集。</span><br><span class="line"></span><br><span class="line">## Facebook 加载方案</span><br><span class="line"></span><br><span class="line">Facebook的思路是将 **MultiDex.install()** 操作放在另外一个经常进行的。</span><br><span class="line"></span><br><span class="line">- dex 形式</span><br><span class="line"></span><br><span class="line">   与微信相同。</span><br><span class="line"></span><br><span class="line">- dex 类分包规则</span><br><span class="line"></span><br><span class="line">   Facebook 将加载 dex 的逻辑单独放于一个单独的 nodex 进程中。</span><br></pre></td></tr></table></figure></p>
<p><activity android:exported="false" android:process=":nodex" android:name="com.facebook.nodex.startup.splashscreen.NodexSplashActivity"><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">所有的依赖集为 Application、NodexSplashActivity 的间接依赖集即可。</span><br><span class="line"></span><br><span class="line">- 加载 dex 的方式</span><br><span class="line"></span><br><span class="line">  因为 NodexSplashActivity 的 intent-filter 指定为 Main 和LAUNCHER ，所以一打开 App 首先拉起 nodex 进程，然后打开 NodexSplashActivity 进行 MultiDex.install() 。如果已经进行了 dexpot 操作的话就直接跳转主界面，没有的话就等待 dexpot 操作完成再跳转主界面。</span><br><span class="line"></span><br><span class="line">这种方式好处在于依赖集非常简单，同时首次加载 dex 时也不会卡死。但是它的缺点也很明显，即每次启动主进程时，都需先启动 nodex 进程。尽管 nodex 进程逻辑非常简单，这也需100ms以上。</span><br><span class="line"></span><br><span class="line">## 美团加载方案</span><br><span class="line">- dex 形式</span><br><span class="line">  在 gradle 生成 dex 文件的这步中，自定义一个 task 来干预 dex 的生产过程，从而产生多个 dex 。</span><br></pre></td></tr></table></figure></activity></p>
<p> tasks.whenTaskAdded { task -&gt;<br>    if (task.name.startsWith(‘proguard’) &amp;&amp; (task.name.endsWith(‘Debug’) || task.name.endsWith(‘Release’))) {<br>        task.doLast {<br>            makeDexFileAfterProguardJar();<br>        }<br>        task.doFirst {<br>            delete “${project.buildDir}/intermediates/classes-proguard”;</p>
<pre><code>        String flavor = task.name.substring(&apos;proguard&apos;.length(), task.name.lastIndexOf(task.name.endsWith(&apos;Debug&apos;) ? &quot;Debug&quot; : &quot;Release&quot;));
        generateMainIndexKeepList(flavor.toLowerCase());
    }
} else if (task.name.startsWith(&apos;zipalign&apos;) &amp;&amp; (task.name.endsWith(&apos;Debug&apos;) || task.name.endsWith(&apos;Release&apos;))) {
    task.doFirst {
        ensureMultiDexInApk();
    }
}
</code></pre><p>}<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- dex 类分包规则</span><br><span class="line"> 把 Service、Receiver、Provider 涉及到的代码都放到主 dex 中，而把 Activity 涉及到的代码进行了一定的拆分，把首页 Activity、Laucher Activity 、欢迎页的 Activity 、城市列表页 Activity 等所依赖的 class 放到了主 dex 中，把二级、三级页面的 Activity 以及业务频道的代码放到了第二个 dex 中，为了减少人工分析 class 的依赖所带了的不可维护性和高风险性，美团编写了一个能够自动分析 class 依赖的脚本， 从而能够保证主 dex 包含 class 以及他们所依赖的所有 class 都在其内，这样这个脚本就会在打包之前自动分析出启动到主 dex 所涉及的所有代码，保证主 dex 运行正常。</span><br><span class="line">- 加载 dex 的方式</span><br><span class="line"> 通过分析 Activity 的启动过程，发现 Activity 是由 ActivityThread 通过 Instrumentation 来启动的，那么是否可以在 Instrumentation 中做一定的手脚呢？通过分析代码 ActivityThread 和 Instrumentation 发现，Instrumentation 有关 Activity 启动相关的方法大概有：execStartActivity、 newActivity 等等，这样就可以在这些方法中添加代码逻辑进行判断这个 class 是否加载了，如果加载则直接启动这个 Activity，如果没有加载完成则启动一个等待的 Activity 显示给用户，然后在这个 Activity 中等待后台第二个 dex 加载完成，完成后自动跳转到用户实际要跳转的 Activity；这样在代码充分解耦合，以及每个业务代码能够做到颗粒化的前提下，就做到第二个 dex 的按需加载了。 </span><br><span class="line"></span><br><span class="line">美团的这种方式对主 dex 的要求非常高，因为第二个 dex 是等到需要的时候再去加载。重写Instrumentation 的 execStartActivity 方法，hook 跳转 Activity 的总入口做判断，如果当前第二个 dex 还没有加载完成，就弹一个 loading Activity等待加载完成。</span><br><span class="line"></span><br><span class="line">## 综合加载方案</span><br><span class="line">微信的方案需要将 dex 放于 assets 目录下，在打包的时候太过负责；Facebook 的方案每次进入都是开启一个 nodex 进程，而我们希望节省资源的同时快速打开 App；美团的方案确实很 hack，但是对于项目已经很庞大，耦合度又比较高的情况下并不适合。所以这里尝试结合三个方案，针对自己的项目来进行优化。</span><br><span class="line"></span><br><span class="line">- dex 形式</span><br><span class="line">第一，为了能够继续支持 Android 2.x 的机型，我们将每个包的方法数控制在 48000 个，这样最后分出来 dex 包大约在 5M 左右；第二，为了防止 NoClassDefFoundError 的情况，我们找出来启动页、引导页、首页比较在意的一些类，比如 Fragment 等（因为在生成 maindexlist.txt 的时候只会找 Activity 的直接引用，比如首页 Activity 直接引用 AFragemnt，但是 AFragment 的引用并没有去找）。</span><br><span class="line"></span><br><span class="line">- dex 类分包规则</span><br><span class="line">第一个包放 Application、Android四大组件以及启动页、引导页、首页的直接引用的 Fragment 的引用类，还放了推送消息过来点击 Notification 之后要展示的 Activity 中的 Fragment 的引用类。</span><br><span class="line">Fragment 的引用类是写了一个脚本，输入需要找的类然后将这些引用类写到 multidex.keep 文件中，如果是 debug 的就直接在生成的 jar 里面找，如果是 release 的话就通过 mapping.txt 找，找不到的话再去 jar 里面找，所以在 gradle 打包的过程中我们人为干扰一下：</span><br></pre></td></tr></table></figure></p>
<p>tasks.whenTaskAdded { task -&gt;<br>    if (task.name.startsWith(“create”) &amp;&amp; task.name.endsWith(“MainDexClassList”)) {<br>        task.doLast {<br>            def flavorAndBuildType = task.name.substring(“create”.length(), task.name.length() - “MainDexClassList”.length())<br>            autoSplitDex.configure {<br>                description = flavorAndBuildType<br>            }<br>            autoSplitDex.execute()<br>        }<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">详细代码可见：Github — PhotoNoter/gradle</span><br><span class="line"></span><br><span class="line">- 加载 dex 的方式</span><br><span class="line">在防止 ANR 方面，我们采用了 Facebook 的思路。但是稍微有一点区别，差别在于我们并不在一开启 App 的时候就去起进程，而是一开启 App 的时候在主进程里面判断是否 dexopt 过没，没有的话再去起另外的进程的 Activity 专门做 dexopt 操作 。一旦拉起了去做 dexopt 的进程，那么让主进程进入一个死循环，一直等到 dexopt 进程结束再结束死循环往下走。那么问题来了，第一，主进程进入死循环会 ANR 吗？第二，如何判断是否 dexopt 过；第三，为了界面友好，dexopt 的进程该怎么做；第四，主进程怎么知道 dexopt 进程结束了，也就是怎么去做进程间通信。</span><br><span class="line"></span><br><span class="line"> - 一个一个问题的解决，先第一个：因为当拉起 dexopt 进程之后，我们在 dexopt 进程的 Activity 中进行 MultiDex.install() 操作，此时主进程不再是前台进程了，所以不会 ANR 。</span><br><span class="line"></span><br><span class="line"> - 第二个问题：因为第一次启动是什么数据都没有的，那么我们就建立一个 SharedPreference ，启动的时候先去从这里获取数据，如果没有数据那么也就是没有 dexopt 过，如果有数据那么肯定是 dexopt 过的，但是这个 SharedPreference 我们得保证我们的程序只有这个地方可以修改，其他地方不能修改。</span><br><span class="line"></span><br><span class="line"> - 第三个问题：因为 App 的启动也是一张图片，所以在 dexopt 的 Activity 的 layout 中，我们就把这张图片设置上去就好了，当关闭 dexopt 的 Activity 的时候，我们得关闭 Activity 的动画。同时为了不让 dexopt 进程发生 ANR ，我们将 MultiDex.install() 过程放在了子线程中进行。</span><br><span class="line"></span><br><span class="line"> - 第四个问题：Linux 的进程间通信的方式有很多，Android 中还有 Binder 等，那么我们这里采用哪种方式比较好呢？首先想到的是既然 dexopt 进程结束了自然在主进程的死循环中去判断 dexopt 进程是否存在。但是在实际操作中发现，dexopt 虽然已经退出了，但是进程并没有马上被回收掉，所以这个方法走不通。那么用 Broadcast 广播可以吗？可是可以，但是增加了 Application 的负担，在拉起 dexopt 进程前还得注册一个动态广播，接收到广播之后还得注销掉，所以这个也没有采用。那么最终采用的方式是判断文件是否存在，在拉起 dexopt 进程前在某个安全的地方建立一个临时文件，然后死循环判断这个文件是否存在，在 dexopt 进程结束的时候删除这个临时文件，那么在主进程的死循环中发现此文件不存在了，就直接跳出循环，继续 Application 初始化操作。</span><br></pre></td></tr></table></figure></p>
<p>public class NoteApplication extends Application {<br>@Override<br>    protected void attachBaseContext(Context base) {<br>        super.attachBaseContext(base);<br>        //开启dex进程的话也会进入application<br>        if (isDexProcess()) {<br>            return;<br>        }<br>        doInstallBeforeLollipop();<br>        MultiDex.install(this);<br>    }</p>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (isDexProcess()) {
        return;
    }
  //其他初始化
}
</code></pre><p>  private void doInstallBeforeLollipop() {<br>        //满足3个条件，1.第一次安装开启，2.主进程，3.API<21(因为21之后art的速度比dalvik快接近10倍(毕竟5.0之后的手机性能也要好很多)) if="" (isappfirstinstall()="" &&="" !isdexprocessorotherprocesses()="" build.version.sdk_int="" <="" build.version_codes.lollipop)="" {="" try="" createtempfile();="" startdexprocess();="" while="" (true)="" (existtempfile())="" thread.sleep(50);="" }="" catch="" (interruptedexception="" e)="" e.printstacktrace();="" else="" setappnotefirstinstall();="" break;="" (ioexception="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    详细代码可见：Github — PhotoNoter/NoteApplication</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总的来说，这种方式好处在于依赖集非常简单，同时它的集成方式也是非常简单，我们无须去修改与加载无关的代码。但是当没有启动过 App 的时候，被推送全家桶唤醒或者收到了广播，虽然这里都是没有界面的过程，但是运用了这种加载方式的话会弹出 dexopt 进程的 Activity，用户看到会一脸懵比的。</span><br><span class="line">推荐插件： https://github.com/TangXiaoLv/Android-Easy-MultiDex</span><br><span class="line"></span><br><span class="line">坑</span><br><span class="line">Too many classes in –main-dex-list</span><br><span class="line">UNEXPECTED TOP-LEVEL EXCEPTION:com.android.dex.DexException: Too many classes in –main-dex-list, main dex capacity exceeded at com.android.dx.command.dexer.Main.processAllFiles(Main.java:494) at com.android.dx.command.dexer.Main.runMultiDex(Main.java:332) at com.android.dx.command.dexer.Main.run(Main.java:243) at com.android.dx.command.dexer.Main.main(Main.java:214) at com.android.dx.command.Main.main(Main.java:106)</span><br><span class="line"></span><br><span class="line">通过 sdk 的 mainDexClasses.rules 知道主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就引发了 main dex capacity exceeded build error 。</span><br><span class="line"></span><br><span class="line">为了解决这个问题，当执行 Create&#123;flavor&#125;&#123;buildType&#125;ManifestKeepList task 之前将其中的 activity 去掉，之后会发现 /build/intermediates/multi_dex/&#123;flavor&#125;/&#123;buildType&#125;/manifest_keep.txt 文件中已经没有 Activity 相关的类了。</span><br><span class="line"></span><br><span class="line">def patchKeepSpecs() &#123;</span><br><span class="line">    def taskClass = &quot;com.android.build.gradle.internal.tasks.multidex.CreateManifestKeepList&quot;;</span><br><span class="line">    def clazz = this.class.classLoader.loadClass(taskClass)</span><br><span class="line">    def keepSpecsField = clazz.getDeclaredField(&quot;KEEP_SPECS&quot;)</span><br><span class="line">    keepSpecsField.setAccessible(true)</span><br><span class="line">    def keepSpecsMap = (Map) keepSpecsField.get(null)</span><br><span class="line">    if (keepSpecsMap.remove(&quot;activity&quot;) != null) &#123;</span><br><span class="line">        println &quot;KEEP_SPECS patched: removed &apos;activity&apos; root&quot;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println &quot;Failed to patch KEEP_SPECS: no &apos;activity&apos; root found&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">patchKeepSpecs()</span><br><span class="line">详细可以看 CreateManifestKeepList 的源码：Github – CreateManifestKeepList</span><br><span class="line"></span><br><span class="line">Too many classes in –main-dex-list</span><br><span class="line">没错，还是 Too many classes in –main-dex-list 的错误。在美团的自动拆包中讲到：</span><br><span class="line"></span><br><span class="line">实际应用中我们还遇到另外一个比较棘手的问题， 就是Field的过多的问题，Field过多是由我们目前采用的代码组织结构引入的，我们为了方便多业务线、多团队并发协作的情况下开发，我们采用的aar的方式进行开发，并同时在aar依赖链的最底层引入了一个通用业务aar，而这个通用业务aar中包含了很多资源，而ADT14以及更高的版本中对Library资源处理时，Library的R资源不再是static final的了，详情请查看google官方说明，这样在最终打包时Library中的R没法做到内联，这样带来了R field过多的情况，导致需要拆分多个Secondary DEX，为了解决这个问题我们采用的是在打包过程中利用脚本把Libray中R field（例如ID、Layout、Drawable等）的引用替换成常量，然后删去Library中R.class中的相应Field。</span><br><span class="line"></span><br><span class="line">同样，hu关于这个问题可以参考这篇大神的文章：当Field邂逅65535 。</span><br><span class="line"></span><br><span class="line">DexException: Library dex files are not supported in multi-dex mode</span><br><span class="line">com.android.dex.DexException: Library dex files are not supported in multi-dex mode</span><br><span class="line">​ at com.android.dx.command.dexer.Main.runMultiDex(Main.java:322)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.run(Main.java:228)</span><br><span class="line">​ at com.android.dx.command.dexer.Main.main(Main.java:199)</span><br><span class="line">​ at com.android.dx.command.Main.main(Main.java:103)</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        preDexLibraries = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">OutOfMemoryError: Java heap space</span><br><span class="line">UNEXPECTED TOP-LEVEL ERROR:</span><br><span class="line">​ java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        javaMaxHeapSize &quot;2g&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></21(因为21之后art的速度比dalvik快接近10倍(毕竟5.0之后的手机性能也要好很多))></p>
<h3 id="Android-分包之旅技术分享疑难解答"><a href="#Android-分包之旅技术分享疑难解答" class="headerlink" title="Android 分包之旅技术分享疑难解答"></a>Android 分包之旅技术分享疑难解答</h3><p>Q1：Facebook mutidex 方案为何要多起一个进程，如果采用单进程 线程去处理呢？<br>答：install能不能放到线程里做？如果开新线程加载，而主线程继续Application初始化—-——导致如果异步化，multidex安装没有结束意味着dex还没加载进来，这时候如果进程需要seconday.dex里的classes信息不就悲剧了—-某些类强行使用就会报NoClassDefFoundError.<br>FaceBook多dex分包方案<br>安装完成之后第一次启动时，是secondary.dex的dexopt花费了更多的时间，认识到这点非常重要，使得问题转化为：在不阻塞UI线程的前提下，完成dexopt，以后都不需要再次dexopt，所以可以在UI线程install dex了<br>我们现在想做到的是：既希望在Application的attachContext（）方法里同步加载secondary.dex，又不希望卡住UI线程<br>FB的方案就是：<br>让Launcher Activity在另外一个进程启动，但是Multidex.install还是在Main Process中开启，虽然逻辑上已经不承担dexopt的任务<br>这个Launcher Activity就是用来异步触发dexopt的 ，load完成就启动Main Activity；如果已经loaded，则直接启动Main Process<br>Multidex.install所引发的合并耗时操作，是在前台进程的异步任务中执行的，所以没有anr的风险</p>
<p>Q2：当没有启动过 App 的时候，被推送全家桶唤醒或者收到了广播（App已经处于不是第一次启动过）<br>会唤醒，而且会出现dexopt的独立进程页面activity，一闪而过用户会懵逼…<br>改进采用新的思路会唤起新进程，但是该进程只会触发一次…<br>如何保证只触发一次？ 我们先判断是否第一次安装启动应用，当应用不是第一次安装启动时，我们直接启动闪屏页，并且结束掉子进程即可。</p>
<p>Q3:处于第一次安装成功之后，app收到推送全家桶是否会被唤醒？<br>不会，因为需要首次在application执行过一次推送的init代码才会被唤醒<br>Q4:最终方案？<br>示例代码参考 ：<a href="https://github.com/yuyang272999712/NewFeaturesTest/blob/master/app/src/main/java/com/yuyang/fitsystemwindowstestdrawer/MyApplication.java" target="_blank" rel="noopener">https://github.com/yuyang272999712/NewFeaturesTest/blob/master/app/src/main/java/com/yuyang/fitsystemwindowstestdrawer/MyApplication.java</a><br>方案思路参考：<a href="https://www.jianshu.com/p/9072ca9718ce" target="_blank" rel="noopener">https://www.jianshu.com/p/9072ca9718ce</a><br>             <a href="https://juejin.im/entry/5a7807926fb9a063517250b1" target="_blank" rel="noopener">https://juejin.im/entry/5a7807926fb9a063517250b1</a></p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/10/CommonUtils/" rel="next" title="Android工具类常用的几种方法">
                <i class="fa fa-chevron-left"></i> Android工具类常用的几种方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/10/job2018/" rel="prev" title="2018年年底Android悲催的面试之路">
                2018年年底Android悲催的面试之路 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/default_avatar.jpg" alt="Mikee">
          <p class="site-author-name" itemprop="name">Mikee</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#INSTALL-FAILED-DEXOPT"><span class="nav-number">1.</span> <span class="nav-text">INSTALL_FAILED_DEXOPT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65536"><span class="nav-number">2.</span> <span class="nav-text">65536</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-分包之旅技术分享疑难解答"><span class="nav-number">2.1.</span> <span class="nav-text">Android 分包之旅技术分享疑难解答</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mikee</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
