<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="Java面试题面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或">
<meta property="og:type" content="article">
<meta property="og:title" content="Mikee的八度空间">
<meta property="og:url" content="http://yoursite.com/2018/12/15/Java面试题/index.html">
<meta property="og:site_name" content="Mikee的八度空间">
<meta property="og:description" content="Java面试题面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">
<meta property="og:image" content="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8">
<meta property="og:updated_time" content="2018-12-18T17:05:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mikee的八度空间">
<meta name="twitter:description" content="Java面试题面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象. 多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:  可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或">
<meta name="twitter:image" content="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title>  | Mikee的八度空间 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mikee的八度空间</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-15T05:49:50+08:00" content="2018-12-15">
              2018-12-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h2><h4 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h4><p>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.</p>
<h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p>
<ol>
<li>可替换性:多态对已存在代码具有可替换性.</li>
<li>可扩充性:增加新的子类不影响已经存在的类结构.</li>
<li>接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.</li>
<li>灵活性:</li>
<li>简化性:</li>
</ol>
<h4 id="代码中如何实现多态"><a href="#代码中如何实现多态" class="headerlink" title="代码中如何实现多态"></a>代码中如何实现多态</h4><p>实现多态主要有以下三种方式:</p>
<ol>
<li>接口实现</li>
<li>继承父类重写方法</li>
<li>同一类中进行方法重载</li>
</ol>
<h4 id="虚拟机是如何实现多态的"><a href="#虚拟机是如何实现多态的" class="headerlink" title="虚拟机是如何实现多态的"></a>虚拟机是如何实现多态的</h4><p>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.</p>
<h4 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h4><p>接口的意义用三个词就可以概括:规范,扩展,回调.</p>
<h4 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h4><p>抽象类的意义可以用三句话来概括:</p>
<ol>
<li>为其他子类提供一个公共的类型</li>
<li>封装子类中重复定义的内容</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的</li>
</ol>
<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><table>
<thead>
<tr>
<th>比较</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认方法</td>
<td>抽象类可以有默认的方法实现</td>
<td>java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td>实现方式</td>
<td>子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td>子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类中可以有构造器</td>
<td>接口中不能</td>
</tr>
<tr>
<td>和正常类区别</td>
<td>抽象类不能被实例化</td>
<td>接口则是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public,protected和default等修饰</td>
<td>接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td>多继承</td>
<td>一个子类只能存在一个父类</td>
<td>一个子类可以存在多个接口</td>
</tr>
<tr>
<td>添加新方法</td>
<td>想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td>如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
</tbody>
</table>
<h4 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h4><p>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.</p>
<h4 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a>什么是不可变对象</h4><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<h4 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别?"></a>静态变量和实例变量的区别?</h4><p>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.</p>
<h4 id="能否创建一个包含可变对象的不可变对象"><a href="#能否创建一个包含可变对象的不可变对象" class="headerlink" title="能否创建一个包含可变对象的不可变对象?"></a>能否创建一个包含可变对象的不可变对象?</h4><p>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.</p>
<h4 id="java-创建对象的几种方式"><a href="#java-创建对象的几种方式" class="headerlink" title="java 创建对象的几种方式"></a>java 创建对象的几种方式</h4><ol>
<li>采用new</li>
<li>通过反射</li>
<li>采用clone</li>
<li>通过序列化机制</li>
</ol>
<p>前2者都需要显式地调用构造方法.   造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.</p>
<h4 id="switch中能否使用string做参数"><a href="#switch中能否使用string做参数" class="headerlink" title="switch中能否使用string做参数"></a>switch中能否使用string做参数</h4><p>在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.</p>
<h4 id="switch能否作用在byte-long上"><a href="#switch能否作用在byte-long上" class="headerlink" title="switch能否作用在byte,long上?"></a>switch能否作用在byte,long上?</h4><p>可以用在byte上,但是不能用在long上.</p>
<h4 id="String-s1-”ab”-String-s2-”a”-”b”-String-s3-”a”-String-s4-”b”-s5-s3-s4请问s5-s2返回什么"><a href="#String-s1-”ab”-String-s2-”a”-”b”-String-s3-”a”-String-s4-”b”-s5-s3-s4请问s5-s2返回什么" class="headerlink" title="String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?"></a>String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?</h4><p> 返回false.在编译过程中,编译器会将s2直接优化为”ab”,会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String(“ab”);</p>
<h4 id="你对String对象的intern-熟悉么"><a href="#你对String对象的intern-熟悉么" class="headerlink" title="你对String对象的intern()熟悉么?"></a>你对String对象的intern()熟悉么?</h4><p> intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回.<br> 比如<br> String s1=”aa”;<br> String s2=s1.intern();<br> System.out.print(s1==s2);//返回false</p>
<h4 id="Object中有哪些公共方法"><a href="#Object中有哪些公共方法" class="headerlink" title="Object中有哪些公共方法?"></a>Object中有哪些公共方法?</h4><ol>
<li><code>equals()</code></li>
<li><code>clone()</code></li>
<li><code>getClass()</code></li>
<li><code>notify(),notifyAll(),wait()</code></li>
<li><code>toString</code></li>
</ol>
<h4 id="java当中的四种引用"><a href="#java当中的四种引用" class="headerlink" title="java当中的四种引用"></a>java当中的四种引用</h4><p>强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</p>
<ol>
<li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li>
<li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li>
<li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ol>
<p>更多了解参见<a href="http://blog.csdn.net/dd864140130/article/details/49885811" target="_blank" rel="noopener">深入对象引用</a></p>
<h4 id="WeakReference与SoftReference的区别"><a href="#WeakReference与SoftReference的区别" class="headerlink" title="WeakReference与SoftReference的区别?"></a>WeakReference与SoftReference的区别?</h4><p>这点在四种引用类型中已经做了解释,这里简单说明一下即可:<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</p>
<h4 id="为什么要有不同的引用类型"><a href="#为什么要有不同的引用类型" class="headerlink" title="为什么要有不同的引用类型"></a>为什么要有不同的引用类型</h4><p>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:</p>
<ol>
<li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li>
<li>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.</li>
</ol>
<h4 id="java中-和eqauls-的区别-equals-和hashcode的区别"><a href="#java中-和eqauls-的区别-equals-和hashcode的区别" class="headerlink" title="java中==和eqauls()的区别,equals()和hashcode的区别"></a>java中==和<code>eqauls()</code>的区别,<code>equals()</code>和<code>hashcode</code>的区别</h4><p>==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法</p>
<h4 id="equals-和hashcode-的联系"><a href="#equals-和hashcode-的联系" class="headerlink" title="equals()和hashcode()的联系"></a><code>equals()</code>和<code>hashcode()</code>的联系</h4><p><code>hashCode()</code>是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.<br>如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)</p>
<h4 id="a-hashCode-有什么用-与a-equals-b-有什么关系"><a href="#a-hashCode-有什么用-与a-equals-b-有什么关系" class="headerlink" title="a.hashCode()有什么用?与a.equals(b)有什么关系"></a>a.hashCode()有什么用?与a.equals(b)有什么关系</h4><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。</p>
<p>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.</p>
<h4 id="有没有可能两个不相等的对象有相同的hashcode"><a href="#有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能两个不相等的对象有相同的hashcode"></a>有没有可能两个不相等的对象有相同的hashcode</h4><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立.</p>
<h4 id="可以在hashcode中使用随机数字吗"><a href="#可以在hashcode中使用随机数字吗" class="headerlink" title="可以在hashcode中使用随机数字吗?"></a>可以在hashcode中使用随机数字吗?</h4><p>不行，因为同一对象的 hashcode 值必须是相同的</p>
<h4 id="a-b与a-equals-b-有什么区别"><a href="#a-b与a-equals-b-有什么区别" class="headerlink" title="a==b与a.equals(b)有什么区别"></a>a==b与a.equals(b)有什么区别</h4><p>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h4 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3*0.1==0.3返回值是什么"></a><code>3*0.1==0.3</code>返回值是什么</h4><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h4 id="a-a-b与a-b有什么区别吗"><a href="#a-a-b与a-b有什么区别吗" class="headerlink" title="a=a+b与a+=b有什么区别吗?"></a>a=a+b与a+=b有什么区别吗?</h4><p>+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：<br>byte a = 127;<br>byte b = 127;<br>b = a + b; // error : cannot convert from int to byte<br>b += a; // ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<h4 id="short-s1-1-s1-s1-1-该段代码是否有错-有的话怎么改？"><a href="#short-s1-1-s1-s1-1-该段代码是否有错-有的话怎么改？" class="headerlink" title="short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？"></a>short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</h4><p>有错误,short类型在进行运算时会自动提升为int类型,也就是说<code>s1+1</code>的运算结果是int类型.</p>
<h4 id="short-s1-1-s1-1-该段代码是否有错-有的话怎么改？"><a href="#short-s1-1-s1-1-该段代码是否有错-有的话怎么改？" class="headerlink" title="short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？"></a>short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？</h4><p>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型,所以没错.</p>
<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp;的区别"></a>&amp; 和 &amp;&amp;的区别</h4><p>首先记住&amp;是位操作,而&amp;&amp;是逻辑运算符.另外需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name!=<span class="keyword">null</span>&amp;userName.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"erro"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码将会抛出空指针异常.</p>
<h4 id="一个-java文件内部可以有类-非内部类"><a href="#一个-java文件内部可以有类-非内部类" class="headerlink" title="一个.java文件内部可以有类?(非内部类)"></a>一个.java文件内部可以有类?(非内部类)</h4><p>只能有一个public公共类,但是可以有多个default修饰的类.</p>
<h4 id="如何正确的退出多层嵌套循环"><a href="#如何正确的退出多层嵌套循环" class="headerlink" title="如何正确的退出多层嵌套循环."></a>如何正确的退出多层嵌套循环.</h4><ol>
<li>使用标号和break;</li>
<li>通过在外层循环中添加标识符</li>
</ol>
<h4 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h4><p>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.</p>
<p>内部类提供了更好的封装,除了该外围类,其他类都不能访问</p>
<h4 id="final-finalize和finally的不同之处"><a href="#final-finalize和finally的不同之处" class="headerlink" title="final,finalize和finally的不同之处"></a>final,finalize和finally的不同之处</h4><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是<strong>在对象被回收之前调用的方法</strong>，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<h4 id="clone-是哪个类的方法"><a href="#clone-是哪个类的方法" class="headerlink" title="clone()是哪个类的方法?"></a>clone()是哪个类的方法?</h4><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h4 id="深拷贝和浅拷贝的区别是什么"><a href="#深拷贝和浅拷贝的区别是什么" class="headerlink" title="深拷贝和浅拷贝的区别是什么?"></a>深拷贝和浅拷贝的区别是什么?</h4><p>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p>
<h4 id="static都有哪些用法"><a href="#static都有哪些用法" class="headerlink" title="static都有哪些用法?"></a>static都有哪些用法?</h4><p>几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.</p>
<p>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//执行相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.</p>
<p>最后一种用法就是静态导包,即<code>import static</code>.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final有哪些用法"><a href="#final有哪些用法" class="headerlink" title="final有哪些用法"></a>final有哪些用法</h4><p>final也是很多面试喜欢问的地方,能回答下以下三点就不错了:<br>1.被final修饰的类不可以被继承<br>2.被final修饰的方法不可以被重写<br>3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.<br>4.被final修饰的方法,JVM会尝试将其<strong>内联</strong>,以提高运行效率<br>5.被final修饰的常量,在编译阶段会存入常量池中.</p>
<p>回答出编译器对final域要遵守的两个重排序规则更好:<br>1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.<br>2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</p>
<hr>
<h3 id="数据类型相关"><a href="#数据类型相关" class="headerlink" title="数据类型相关"></a>数据类型相关</h3><h4 id="java中int-char-long各占多少字节"><a href="#java中int-char-long各占多少字节" class="headerlink" title="java中int char,long各占多少字节?"></a>java中int char,long各占多少字节?</h4><table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>|float|4|32<br>|double|8|64|<br>|char|2|16|</p>
<h4 id="64位的JVM当中-int的长度是多少"><a href="#64位的JVM当中-int的长度是多少" class="headerlink" title="64位的JVM当中,int的长度是多少?"></a>64位的JVM当中,int的长度是多少?</h4><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h4 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h4><p>Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.</p>
<h4 id="int-和Integer谁占用的内存更多"><a href="#int-和Integer谁占用的内存更多" class="headerlink" title="int 和Integer谁占用的内存更多?"></a>int 和Integer谁占用的内存更多?</h4><p>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h4 id="String-StringBuffer和StringBuilder区别"><a href="#String-StringBuffer和StringBuilder区别" class="headerlink" title="String,StringBuffer和StringBuilder区别"></a>String,StringBuffer和StringBuilder区别</h4><p>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);<br>StringBuilder 字符串变量(线程不安全).</p>
<h4 id="String和StringBuffer"><a href="#String和StringBuffer" class="headerlink" title="String和StringBuffer"></a>String和StringBuffer</h4><p>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.</p>
<p>StringBuffer是对对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer.</p>
<p>但是需要注意现在JVM会对String拼接做一定的优化:<br><code>String s=“This is only ”+”simple”+”test”</code>会被虚拟机直接优化成<code>String s=“This is only simple test”</code>,此时就不存在拼接过程.</p>
<h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>StringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是jdk 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.</p>
<h4 id="什么是编译器常量-使用它有什么风险"><a href="#什么是编译器常量-使用它有什么风险" class="headerlink" title="什么是编译器常量?使用它有什么风险?"></a>什么是编译器常量?使用它有什么风险?</h4><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h4 id="java当中使用什么类型表示价格比较好"><a href="#java当中使用什么类型表示价格比较好" class="headerlink" title="java当中使用什么类型表示价格比较好?"></a>java当中使用什么类型表示价格比较好?</h4><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<h4 id="如何将byte转为String"><a href="#如何将byte转为String" class="headerlink" title="如何将byte转为String"></a>如何将byte转为String</h4><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<h4 id="可以将int强转为byte类型么-会产生什么问题"><a href="#可以将int强转为byte类型么-会产生什么问题" class="headerlink" title="可以将int强转为byte类型么?会产生什么问题?"></a>可以将int强转为byte类型么?会产生什么问题?</h4><p>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128</p>
<hr>
<h3 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h3><h4 id="你知道哪些垃圾回收算法"><a href="#你知道哪些垃圾回收算法" class="headerlink" title="你知道哪些垃圾回收算法?"></a>你知道哪些垃圾回收算法?</h4><p>垃圾回收从理论上非常容易理解,具体的方法有以下几种:</p>
<ol>
<li>标记-清除</li>
<li>标记-复制</li>
<li>标记-整理</li>
<li>分代回收<br>更详细的内容参见<a href="http://blog.csdn.net/dd864140130/article/details/50084471" target="_blank" rel="noopener">深入理解垃圾回收算法</a></li>
</ol>
<h4 id="如何判断一个对象是否应该被回收"><a href="#如何判断一个对象是否应该被回收" class="headerlink" title="如何判断一个对象是否应该被回收"></a>如何判断一个对象是否应该被回收</h4><p>这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.</p>
<h4 id="简单的解释一下垃圾回收"><a href="#简单的解释一下垃圾回收" class="headerlink" title="简单的解释一下垃圾回收"></a>简单的解释一下垃圾回收</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.</p>
<h4 id="调用System-gc-会发生什么"><a href="#调用System-gc-会发生什么" class="headerlink" title="调用System.gc()会发生什么?"></a>调用System.gc()会发生什么?</h4><p>通知GC开始工作,但是GC真正开始的时间不确定.</p>
<hr>
<h3 id="进程-线程相关"><a href="#进程-线程相关" class="headerlink" title="进程,线程相关"></a>进程,线程相关</h3><h4 id="说说进程-线程-协程之间的区别"><a href="#说说进程-线程-协程之间的区别" class="headerlink" title="说说进程,线程,协程之间的区别"></a>说说进程,线程,协程之间的区别</h4><p>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.</p>
<h4 id="你了解守护线程吗-它和非守护线程有什么区别"><a href="#你了解守护线程吗-它和非守护线程有什么区别" class="headerlink" title="你了解守护线程吗?它和非守护线程有什么区别"></a>你了解守护线程吗?它和非守护线程有什么区别</h4><p>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程</p>
<h4 id="什么是多线程上下文切换"><a href="#什么是多线程上下文切换" class="headerlink" title="什么是多线程上下文切换"></a>什么是多线程上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h4 id="创建两种线程的方式-他们有什么区别"><a href="#创建两种线程的方式-他们有什么区别" class="headerlink" title="创建两种线程的方式?他们有什么区别?"></a>创建两种线程的方式?他们有什么区别?</h4><p>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p>
<ol>
<li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li>
<li>类可能只要求可执行即可,因此继承整个Thread类的开销过大.</li>
</ol>
<h4 id="Thread类中的start-和run-方法有什么区别"><a href="#Thread类中的start-和run-方法有什么区别" class="headerlink" title="Thread类中的start()和run()方法有什么区别?"></a>Thread类中的start()和run()方法有什么区别?</h4><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h4 id="怎么检测一个线程是否持有对象监视器"><a href="#怎么检测一个线程是否持有对象监视器" class="headerlink" title="怎么检测一个线程是否持有对象监视器"></a>怎么检测一个线程是否持有对象监视器</h4><p>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p>
<h4 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h4><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务</p>
<h4 id="什么导致线程阻塞"><a href="#什么导致线程阻塞" class="headerlink" title="什么导致线程阻塞"></a>什么导致线程阻塞</h4><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sleep()</td>
<td>sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td>
</tr>
<tr>
<td>suspend() 和 resume()</td>
<td>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td>
</tr>
<tr>
<td>yield()</td>
<td>yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td>
</tr>
<tr>
<td>wait() 和 notify()</td>
<td>两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td>
</tr>
</tbody>
</table>
<h4 id="wait-notify-和suspend-resume-之间的区别"><a href="#wait-notify-和suspend-resume-之间的区别" class="headerlink" title="wait(),notify()和suspend(),resume()之间的区别"></a>wait(),notify()和suspend(),resume()之间的区别</h4><p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><p>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h4 id="为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h4><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<h4 id="wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h4><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>
<h4 id="wait-与sleep-的区别"><a href="#wait-与sleep-的区别" class="headerlink" title="wait()与sleep()的区别"></a>wait()与sleep()的区别</h4><p> 关于这两者已经在上面进行详细的说明,这里就做个概括好了:</p>
<ul>
<li>sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li>
<li>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU</li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用</li>
</ul>
<h4 id="为什么wait-nofity和nofityAll这些方法不放在Thread类当中"><a href="#为什么wait-nofity和nofityAll这些方法不放在Thread类当中" class="headerlink" title="为什么wait,nofity和nofityAll这些方法不放在Thread类当中"></a>为什么wait,nofity和nofityAll这些方法不放在Thread类当中</h4><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h4 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a>怎么唤醒一个阻塞的线程</h4><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<h4 id="什么是多线程的上下文切换"><a href="#什么是多线程的上下文切换" class="headerlink" title="什么是多线程的上下文切换"></a>什么是多线程的上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p>
<h4 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么"></a>FutureTask是什么</h4><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>
<h4 id="一个线程如果出现了运行时异常怎么办"><a href="#一个线程如果出现了运行时异常怎么办" class="headerlink" title="一个线程如果出现了运行时异常怎么办?"></a>一个线程如果出现了运行时异常怎么办?</h4><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p>
<h4 id="Java当中有哪几种锁"><a href="#Java当中有哪几种锁" class="headerlink" title="Java当中有哪几种锁"></a>Java当中有哪几种锁</h4><ol>
<li>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</li>
<li>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</li>
<li>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁</li>
</ol>
<h4 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h4><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
<h4 id="如何正确的使用wait-使用if还是while"><a href="#如何正确的使用wait-使用if还是while" class="headerlink" title="如何正确的使用wait()?使用if还是while?"></a>如何正确的使用wait()?使用if还是while?</h4><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">   while (condition does not hold)</span><br><span class="line">     obj.wait(); // (Releases lock, and reacquires on wakeup)</span><br><span class="line">     ... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是线程局部变量ThreadLocal"><a href="#什么是线程局部变量ThreadLocal" class="headerlink" title="什么是线程局部变量ThreadLocal"></a>什么是线程局部变量ThreadLocal</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h4 id="ThreadLoal的作用是什么"><a href="#ThreadLoal的作用是什么" class="headerlink" title="ThreadLoal的作用是什么?"></a>ThreadLoal的作用是什么?</h4><p>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.</p>
<h4 id="生产者消费者模型的作用是什么"><a href="#生产者消费者模型的作用是什么" class="headerlink" title="生产者消费者模型的作用是什么?"></a>生产者消费者模型的作用是什么?</h4><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
<h4 id="写一个生产者-消费者队列"><a href="#写一个生产者-消费者队列" class="headerlink" title="写一个生产者-消费者队列"></a>写一个生产者-消费者队列</h4><p>可以通过阻塞队列实现,也可以通过wait-notify来实现.</p>
<h4 id="使用阻塞队列来实现"><a href="#使用阻塞队列来实现" class="headerlink" title="使用阻塞队列来实现"></a>使用阻塞队列来实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//消费者</span><br><span class="line">public class Producer implements Runnable&#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                Thread.sleep(1000);//模拟耗时</span><br><span class="line">                queue.put(produce());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int produce() &#123;</span><br><span class="line">        int n=new Random().nextInt(10000);</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; produce:&quot; + n);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);//模拟耗时</span><br><span class="line">                consume(queue.take());</span><br><span class="line">            &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void consume(Integer n) &#123;</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; consume:&quot; + n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(100);</span><br><span class="line">        Producer p=new Producer(queue);</span><br><span class="line">        Consumer c1=new Consumer(queue);</span><br><span class="line">        Consumer c2=new Consumer(queue);</span><br><span class="line"></span><br><span class="line">        new Thread(p).start();</span><br><span class="line">        new Thread(c1).start();</span><br><span class="line">        new Thread(c2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用wait-notify来实现"><a href="#使用wait-notify来实现" class="headerlink" title="使用wait-notify来实现"></a>使用wait-notify来实现</h4><p>该种方式应该最经典,这里就不做说明了</p>
<h4 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h4><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p>
<h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>
<h4 id="java中用到的线程调度算法是什么"><a href="#java中用到的线程调度算法是什么" class="headerlink" title="java中用到的线程调度算法是什么"></a>java中用到的线程调度算法是什么</h4><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h4 id="Thread-sleep-0-的作用是什么"><a href="#Thread-sleep-0-的作用是什么" class="headerlink" title="Thread.sleep(0)的作用是什么"></a>Thread.sleep(0)的作用是什么</h4><p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>
<h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功</p>
<h4 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h4><p>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<p>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p>
<h4 id="ConcurrentHashMap的并发度是什么"><a href="#ConcurrentHashMap的并发度是什么" class="headerlink" title="ConcurrentHashMap的并发度是什么?"></a>ConcurrentHashMap的并发度是什么?</h4><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<h4 id="ConcurrentHashMap的工作原理"><a href="#ConcurrentHashMap的工作原理" class="headerlink" title="ConcurrentHashMap的工作原理"></a>ConcurrentHashMap的工作原理</h4><p>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.</p>
<h4 id="jdk-1-6"><a href="#jdk-1-6" class="headerlink" title="jdk 1.6:"></a>jdk 1.6:</h4><p>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。<br>具体实现:ConcurrentHashMap内部有一个Segment<k,v>数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry<k,v>数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。<br>每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。</k,v></k,v></p>
<h4 id="jdk-1-8"><a href="#jdk-1-8" class="headerlink" title="jdk 1.8"></a>jdk 1.8</h4><p>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<h4 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h4><p>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h4 id="java中的-操作符线程安全么"><a href="#java中的-操作符线程安全么" class="headerlink" title="java中的++操作符线程安全么?"></a>java中的++操作符线程安全么?</h4><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差</p>
<h4 id="你有哪些多线程开发良好的实践"><a href="#你有哪些多线程开发良好的实践" class="headerlink" title="你有哪些多线程开发良好的实践?"></a>你有哪些多线程开发良好的实践?</h4><ol>
<li>给线程命名</li>
<li>最小化同步范围</li>
<li>优先使用volatile</li>
<li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li>
<li>优先使用并发容器而非同步容器.</li>
<li>考虑使用线程池</li>
</ol>
<hr>
<h3 id="关于volatile关键字"><a href="#关于volatile关键字" class="headerlink" title="关于volatile关键字"></a>关于volatile关键字</h3><h4 id="可以创建Volatile数组吗"><a href="#可以创建Volatile数组吗" class="headerlink" title="可以创建Volatile数组吗?"></a>可以创建Volatile数组吗?</h4><p>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了</p>
<h4 id="volatile能使得一个非原子操作变成原子操作吗"><a href="#volatile能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile能使得一个非原子操作变成原子操作吗?"></a>volatile能使得一个非原子操作变成原子操作吗?</h4><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 <strong>Java 中读取 long 类型变量不是原子的</strong>，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是<strong>对一个 volatile 型的 long 或 double 变量的读写是原子</strong>。</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是<strong>64位宽</strong>，因此对这两种类型的读是分为两部分的，<strong>第一次读取第一个 32 位，然后再读剩下的 32 位</strong>，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为<strong>内存屏障会将其他所有写的值更新到缓存</strong>。</p>
<h4 id="volatile类型变量提供什么保证"><a href="#volatile类型变量提供什么保证" class="headerlink" title="volatile类型变量提供什么保证?"></a>volatile类型变量提供什么保证?</h4><p>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>
<hr>
<h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><h4 id="Java中的集合及其继承关系"><a href="#Java中的集合及其继承关系" class="headerlink" title="Java中的集合及其继承关系"></a>Java中的集合及其继承关系</h4><p>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:<br><img src="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p>
<p>更多内容可见<a href="http://write.blog.csdn.net/postedit/40826423" target="_blank" rel="noopener">集合类总结</a></p>
<h4 id="poll-方法和remove-方法区别"><a href="#poll-方法和remove-方法区别" class="headerlink" title="poll()方法和remove()方法区别?"></a>poll()方法和remove()方法区别?</h4><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h4 id="LinkedHashMap和PriorityQueue的区别"><a href="#LinkedHashMap和PriorityQueue的区别" class="headerlink" title="LinkedHashMap和PriorityQueue的区别"></a>LinkedHashMap和PriorityQueue的区别</h4><p>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<h4 id="WeakHashMap与HashMap的区别是什么"><a href="#WeakHashMap与HashMap的区别是什么" class="headerlink" title="WeakHashMap与HashMap的区别是什么?"></a>WeakHashMap与HashMap的区别是什么?</h4><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别?"></a>ArrayList和LinkedList的区别?</h4><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是<strong>双向循环链表，不支持随机访问</strong>。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>
<h4 id="ArrayList和Array有什么区别"><a href="#ArrayList和Array有什么区别" class="headerlink" title="ArrayList和Array有什么区别?"></a>ArrayList和Array有什么区别?</h4><ol>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的</li>
</ol>
<h4 id="ArrayList和HashMap默认大小"><a href="#ArrayList和HashMap默认大小" class="headerlink" title="ArrayList和HashMap默认大小?"></a>ArrayList和HashMap默认大小?</h4><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"> </span><br><span class="line"> //from HashMap.java JDK 7</span><br><span class="line"> static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>
<h4 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别?"></a>Comparator和Comparable的区别?</h4><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h4 id="如何实现集合排序"><a href="#如何实现集合排序" class="headerlink" title="如何实现集合排序?"></a>如何实现集合排序?</h4><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<h4 id="如何打印数组内容"><a href="#如何打印数组内容" class="headerlink" title="如何打印数组内容"></a>如何打印数组内容</h4><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<h4 id="LinkedList的是单向链表还是双向"><a href="#LinkedList的是单向链表还是双向" class="headerlink" title="LinkedList的是单向链表还是双向?"></a>LinkedList的是单向链表还是双向?</h4><p>双向循环列表,具体实现自行查阅源码.</p>
<h4 id="TreeMap是实现原理"><a href="#TreeMap是实现原理" class="headerlink" title="TreeMap是实现原理"></a>TreeMap是实现原理</h4><p>采用红黑树实现,具体实现自行查阅源码.</p>
<h4 id="遍历ArrayList时如何正确移除一个元素"><a href="#遍历ArrayList时如何正确移除一个元素" class="headerlink" title="遍历ArrayList时如何正确移除一个元素"></a>遍历ArrayList时如何正确移除一个元素</h4><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<h4 id="什么是ArrayMap-它和HashMap有什么区别"><a href="#什么是ArrayMap-它和HashMap有什么区别" class="headerlink" title="什么是ArrayMap?它和HashMap有什么区别?"></a>什么是ArrayMap?它和HashMap有什么区别?</h4><p>ArrayMap是Android SDK中提供的,非Android开发者可以略过.<br>ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.<br>具体参考这篇文章:<a href="http://lvable.com/?p=217%5D" target="_blank" rel="noopener">ArrayMap VS HashMap</a></p>
<h4 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h4><p>1   HashMap概述：  HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>2   HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap当中，存储最终数据的其实是一个HashMapEntry类型的数组：HashMapEntry<k, v="">[] table。</k,></p>
<p>而HashMapEntry对象其实是属于一种单向链表结构。</p>
<p>这样最终其实是构造了一种二维的结构。</p>
<p>我们看一下HashMapEntry类：</p>
<p>里面有四个元素，key,value,hash值以及指向的下一个节点的对象。</p>
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>
<h4 id="你了解Fail-Fast机制吗"><a href="#你了解Fail-Fast机制吗" class="headerlink" title="你了解Fail-Fast机制吗"></a>你了解Fail-Fast机制吗</h4><p>Fail-Fast即我们常说的快速失败,更多内容参看<a href="http://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">fail-fast机制</a></p>
<h4 id="Fail-fast和Fail-safe有什么区别"><a href="#Fail-fast和Fail-safe有什么区别" class="headerlink" title="Fail-fast和Fail-safe有什么区别"></a>Fail-fast和Fail-safe有什么区别</h4><p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<hr>
<h3 id="关于日期"><a href="#关于日期" class="headerlink" title="关于日期"></a>关于日期</h3><h4 id="SimpleDateFormat是线程安全的吗"><a href="#SimpleDateFormat是线程安全的吗" class="headerlink" title="SimpleDateFormat是线程安全的吗?"></a>SimpleDateFormat是线程安全的吗?</h4><p>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h4 id="如何格式化日期"><a href="#如何格式化日期" class="headerlink" title="如何格式化日期?"></a>如何格式化日期?</h4><p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<hr>
<h3 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h3><h4 id="简单描述java异常体系"><a href="#简单描述java异常体系" class="headerlink" title="简单描述java异常体系"></a>简单描述java异常体系</h4><p>相比没有人不了解异常体系,关于异常体系的更多信息可以见:<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a></p>
<h4 id="什么是异常链"><a href="#什么是异常链" class="headerlink" title="什么是异常链"></a>什么是异常链</h4><p>详情直接参见<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a>,不做解释了.</p>
<h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><p>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：<code>throw new IllegalArgumentException(“size must be multiple of 2″)</code>,<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<hr>
<h4 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h4><h4 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别"></a>Java 中，Serializable 与 Externalizable 的区别</h4><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<hr>
<h3 id="关于JVM"><a href="#关于JVM" class="headerlink" title="关于JVM"></a>关于JVM</h3><h4 id="JVM特性"><a href="#JVM特性" class="headerlink" title="JVM特性"></a>JVM特性</h4><p>平台无关性.<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<h4 id="简单解释一下类加载器"><a href="#简单解释一下类加载器" class="headerlink" title="简单解释一下类加载器"></a>简单解释一下类加载器</h4><p>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,更多的内容参看<a href="http://blog.csdn.net/dd864140130/article/details/49817357" target="_blank" rel="noopener">深入理解JVM加载器</a></p>
<h4 id="简述堆和栈的区别"><a href="#简述堆和栈的区别" class="headerlink" title="简述堆和栈的区别"></a>简述堆和栈的区别</h4><p>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<h4 id="简述JVM内存分配"><a href="#简述JVM内存分配" class="headerlink" title="简述JVM内存分配"></a>简述JVM内存分配</h4><ol>
<li>基本数据类型比变量和对象的引用都是在栈分配的</li>
<li>堆内存用来存放由new创建的对象和数组</li>
<li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li>
<li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li>
<li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li>
</ol>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="java当中采用的是大端还是小端"><a href="#java当中采用的是大端还是小端" class="headerlink" title="java当中采用的是大端还是小端?"></a>java当中采用的是大端还是小端?</h4><p>默认为大端模式</p>
<h4 id="XML解析的几种方式和特点"><a href="#XML解析的几种方式和特点" class="headerlink" title="XML解析的几种方式和特点"></a>XML解析的几种方式和特点</h4><p>DOM,SAX,PULL三种解析方式:</p>
<ul>
<li>DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机</li>
<li>SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</li>
<li>PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</li>
</ul>
<h4 id="JDK-1-7特性"><a href="#JDK-1-7特性" class="headerlink" title="JDK 1.7特性"></a>JDK 1.7特性</h4><p>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\&lt;>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码</p>
<h4 id="JDK-1-8特性"><a href="#JDK-1-8特性" class="headerlink" title="JDK 1.8特性"></a>JDK 1.8特性</h4><p>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<h4 id="Maven和ANT有什么区别"><a href="#Maven和ANT有什么区别" class="headerlink" title="Maven和ANT有什么区别?"></a>Maven和ANT有什么区别?</h4><p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件.</p>
<h4 id="JDBC最佳实践"><a href="#JDBC最佳实践" class="headerlink" title="JDBC最佳实践"></a>JDBC最佳实践</h4><ul>
<li>优先使用批量操作来插入和更新数据</li>
<li>使用PreparedStatement来避免SQL漏洞</li>
<li>使用数据连接池</li>
<li>通过列名来获取结果集</li>
</ul>
<h4 id="IO操作最佳实践"><a href="#IO操作最佳实践" class="headerlink" title="IO操作最佳实践"></a>IO操作最佳实践</h4><ol>
<li>使用有缓冲的IO类,不要单独读取字节或字符</li>
<li>使用NIO和NIO 2或者AIO,而非BIO</li>
<li>在finally中关闭流</li>
<li>使用内存映射文件获取更快的IO</li>
</ol>
<h2 id="Java-常见概念"><a href="#Java-常见概念" class="headerlink" title="Java 常见概念"></a>Java 常见概念</h2><h4 id="1-HashMap和HashTable的区别"><a href="#1-HashMap和HashTable的区别" class="headerlink" title="1.HashMap和HashTable的区别"></a>1.HashMap和HashTable的区别</h4><ul>
<li>[x] HashMap去掉了contains方法</li>
<li>[x] HashTable是<strong>同步</strong>的(线程安全)</li>
<li>[x] HashMap允许空键值</li>
<li>[x] HashMap执行快速失败机制</li>
<li>[ ] <code>Fast-fail</code>机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException</li>
</ul>
<ul>
<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>
</ul>
<ul>
<li>Hashtable和HashMap有几个主要的不同：<strong>线程安全以及速度</strong>。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用<strong>ConcurrentHashMap</strong>吧。</li>
</ul>
<h4 id="2-java的线程安全类"><a href="#2-java的线程安全类" class="headerlink" title="2.java的线程安全类"></a>2.java的线程安全类</h4><p>Vector、Stack、HashTable、ConcurrentHashMap、Properties</p>
<h4 id="3-java集合框架"><a href="#3-java集合框架" class="headerlink" title="3.java集合框架"></a>3.java集合框架</h4><ul>
<li>Collection - List<ul>
<li>有顺序以线性方式存储,可以存放重复对象</li>
</ul>
</li>
<li>Collection - List - ArrayList<ul>
<li>数组方式存储数据　　索引数据快插入数据慢　　线程不安全</li>
</ul>
</li>
<li>Collection - List - LinkedList <ul>
<li>双向链表实现存储　　索引数据慢插入数度较快　　线程不安全（比安全性能好）</li>
</ul>
</li>
<li>Collection - List - Vector<ul>
<li>数组方式存储数据　　索引数据快插入数据慢　　线程安全</li>
</ul>
</li>
<li>Collection - List - Vector - Stack<ul>
<li>继承自Vector，实现一个后进先出的堆栈</li>
</ul>
</li>
<li>Collection - Set<ul>
<li>无顺序,不包含重复的元素</li>
</ul>
</li>
<li>Collection - Set - HashSet <ul>
<li>为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。  </li>
</ul>
</li>
<li>Collection - Set - TreeSet<ul>
<li>保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。  </li>
</ul>
</li>
<li>Collection - Set - LinkedHashSet<ul>
<li>具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</li>
</ul>
</li>
<li>Map<ul>
<li>键必须是唯一</li>
</ul>
</li>
<li>Map - HashMap<ul>
<li>HashMap:基于散列表的实现　　允许空键空值　　线程不安全　　(与Hashtable基本一致)</li>
</ul>
</li>
<li>Map - TreeMap<ul>
<li>TreeMap: 基于红黑树数据结构的实现　　不允许空键空值　　线程不安全</li>
</ul>
</li>
<li>Map - HashTable<ul>
<li>Hashtable:基于散列表的实现　　允许空键空值　　线程安全</li>
</ul>
</li>
<li>Map - WeakHashMap<ul>
<li>改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</li>
</ul>
</li>
<li>Map - LinkedHashMap<ul>
<li>具有HashMap的所有特性。</li>
<li>内部对数据的存储也是数组加链表的形式。</li>
<li><strong>多了一个双向链表来维护内部数据的顺序关系。</strong></li>
</ul>
</li>
<li>SparseArray<ul>
<li>采用了二分法方式存储数据（安卓的一个集合类）</li>
<li>key必须为int类型，这中情况下的HashMap可以用SparseArray代替</li>
<li>避免了HashMap自动装箱得到内存消耗</li>
</ul>
</li>
<li>ArrayMap<ul>
<li><code>ArrayMap</code> 实现了<code>implements Map&lt;K, V&gt;</code>接口，所以它也是一个<strong>关联数组、哈希表</strong>。</li>
<li>存储以<code>key-&gt;value</code> 结构形式的数据。</li>
<li>它也是<strong>线程不安全</strong>的，允许<strong>key为null</strong>,<strong>value为null</strong>。</li>
<li>内部实现是<strong>基于两个数组</strong>。 <ul>
<li>一个<code>int[]</code>数组，用于保存每个item的<code>hashCode</code>. </li>
<li>一个<code>Object[]</code>数组，保存<code>key/value</code>键值对。<strong>容量</strong>是上一个数组的<strong>两倍</strong>。 </li>
</ul>
</li>
<li>使用<strong>二分查找法</strong>得到相应的index</li>
</ul>
</li>
</ul>
<blockquote>
<p>在除需要排序时使用TreeSet,TreeMap外,都应使用HashSet,HashMap,因为他们的效率更高。</p>
</blockquote>
<p>3.1 <code>ArrayList</code>的构造函数有三个</p>
<ol>
<li>无参构造 容量为10</li>
<li>ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表</li>
<li>ArrayList(int initialCapacity) 指定初始容量</li>
</ol>
<p>3.2 <code>Iterator(迭代器)</code>支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException)</p>
<h4 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h4><p>4.1 调用system.gc() Runtime.getRuntime.gc()</p>
<p>4.2 垃圾回收:释放那些不再持有任何引用的对象的内存</p>
<p>4.3 怎样判断是否需要收集：</p>
<ol>
<li>引用计数法：对象没有任何引用与之关联(无法解决循环引用)</li>
<li>对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。</li>
</ol>
<p>4.4 垃圾回收方法</p>
<ol>
<li>标记清除法(Mark-Sweeping):易产生内存碎片</li>
<li>复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半</li>
<li>标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚</li>
<li>分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.<br>新生代划分：较大的eden区 和 2个survivor区</li>
</ol>
<p>4.5 内存分配</p>
<ul>
<li>新生代 |Eden Space|From Space|To Space|</li>
<li>对象主要分配在新生代的EdenSpace和FromSpace</li>
<li>如果EdenSapce和FromSpace空间不足,则发起一次GC</li>
<li>若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。</li>
<li>新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC</li>
</ul>
<p>其他</p>
<ul>
<li>优先在Eden上分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代</li>
<li>空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC</li>
</ul>
<h4 id="5-一些重要的关键字"><a href="#5-一些重要的关键字" class="headerlink" title="5.一些重要的关键字"></a>5.一些重要的关键字</h4><ul>
<li><p>volatile<br>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。<code>volatile</code>修饰变量,<strong>每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存</strong>。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序</p>
</li>
<li><p>final<br><code>final</code>修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。</p>
</li>
</ul>
<h4 id="6-多线程-amp-并发-amp-同步-amp-锁"><a href="#6-多线程-amp-并发-amp-同步-amp-锁" class="headerlink" title="6.多线程 &amp; 并发 &amp; 同步 &amp; 锁"></a>6.多线程 &amp; 并发 &amp; 同步 &amp; 锁</h4><p>6.1 线程的run方法和start方法</p>
<ul>
<li><code>start方法</code><br>用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。</li>
<li><code>run方法</code><br>只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。</li>
</ul>
<p>6.2 ReadWriteLock(读写锁)</p>
<p>写写互斥 读写互斥 读读并发<br>在读多写少的情况下可以提高效率 </p>
<p>6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用</p>
<p>6.4 wait与notify、notifyall一起用</p>
<p>6.5 sleep与wait的异同点</p>
<ol>
<li>sleep是Thread类的静态方法,wait来自object类</li>
<li>sleep不释放锁,wait释放锁</li>
<li>wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用</li>
<li>都可以抛出InterruptedException</li>
</ol>
<p>6.6 让一个线程停止执行</p>
<p>异常 - 停止执行<br>休眠 - 停止执行<br>阻塞 - 停止执行</p>
<p>6.7 ThreadLocal相关</p>
<ul>
<li><p>ThreadLocal解决了变量并发访问的冲突问题</p>
<ul>
<li>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</li>
<li><strong>原理</strong><ul>
<li>这个类之所以能够存储每个thread的信息，是因为它的内部有一个Values内部类，而Values中有一个Object组。</li>
<li>Objec数组是以一种近似于map的形式来存储数据的，其中偶数位存ThreadLocal的弱引用，它的下一位存值。</li>
<li>在寻址的时候，Values采用一种很神奇的方式——斐波拉契散列寻址Values里面的getAfterMiss()方式让人觉得很奇怪</li>
</ul>
</li>
</ul>
</li>
<li><p>与synchronized同步机制的比较</p>
<ul>
<li>首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。<br>而ThreadLocal采用了以“以空间换时间”的方式。</li>
</ul>
</li>
</ul>
<h4 id="7-接口与抽象类"><a href="#7-接口与抽象类" class="headerlink" title="7.接口与抽象类"></a>7.接口与抽象类</h4><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口</li>
<li>抽象类可以有构造方法,接口没有构造方法</li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li>
<li>抽象类可以有静态方法，接口不能有静态方法</li>
<li>抽象类中的方法可以是public、protected和默认;接口方法只有public</li>
</ol>
<h4 id="8-Statement接口"><a href="#8-Statement接口" class="headerlink" title="8.Statement接口"></a>8.Statement接口</h4><p>8.1</p>
<ul>
<li>Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞</li>
<li>PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入</li>
<li>CallableStatement接口扩展PreparedStatement，用来调用存储过程</li>
<li>public interface CallableStatement extends PreparedStatement </li>
<li>public interface PreparedStatement extends Statement </li>
<li>BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类</li>
</ul>
<p>8.2 Statement与PrepareStatement的区别</p>
<ul>
<li><p>创建时的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">PreparedStatement preStatement = conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rSet = statement.executeQuery(sql);</span><br><span class="line">ResultSet pSet = preStatement.executeQuery();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，<br>而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些</p>
<ul>
<li>安全性</li>
</ul>
<p>preStatement是预编译的，所以可以有效的防止SQL注入等问题</p>
<ul>
<li>代码的可读性和可维护性</li>
</ul>
<p>PreparedStatement更胜一筹</p>
<h4 id="9-抽象类和最终类"><a href="#9-抽象类和最终类" class="headerlink" title="9.抽象类和最终类"></a>9.抽象类和最终类</h4><p>抽象类可以没有抽象方法,最终类可以,没有最终方法</p>
<p>最终类不能被继承,最终方法不能被重写(可以重载)</p>
<h4 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h4><p>10.1 throw、throws、try…catch、finally</p>
<ol>
<li>throws用在方法上,方法内部通过throw抛出异常</li>
<li>try用于检测包住的语句块,若有异常,抛出并执行catch子句</li>
<li>catch捕获try块中抛出的异常并处理</li>
</ol>
<p>10.2 关于<code>finally</code></p>
<ol>
<li>finally不管有没有异常都要处理</li>
<li>finally{}比return先执行,多个return执行一个后就不在执行</li>
<li>不管有木有异常抛出,finally在return返回前执行</li>
</ol>
<p>10.3 受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
</li>
<li><p>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
</li>
</ol>
<h4 id="11-this-amp-super"><a href="#11-this-amp-super" class="headerlink" title="11.this &amp; super"></a>11.this &amp; super</h4><p>11.1 super出现在父类的子类中。有三种存在方式</p>
<ol>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ol>
<ul>
<li>super只能指代其直接父类</li>
</ul>
<p>11.2 this() &amp; super()在构造方法中的区别</p>
<ol>
<li>调用super()必须写在子类构造方法的第一行,否则编译不通过</li>
<li>super从子类调用父类构造,this在同一类中调用其他构造</li>
<li>均需要放在第一行</li>
<li>尽管可以用this调用一个构造器,却不能调用2个</li>
<li>this和super不能出现在同一个构造器中,否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ol>
<h4 id="12-修饰符一览"><a href="#12-修饰符一览" class="headerlink" title="12.修饰符一览"></a>12.修饰符一览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 			类内部  	同一个包		子类 		任何地方</span><br><span class="line">private 		yes</span><br><span class="line">default         yes			yes</span><br><span class="line">protected		yes			yes				yes</span><br><span class="line">public			yes			yes				yes			yes</span><br></pre></td></tr></table></figure>
<h4 id="13-构造内部类对象"><a href="#13-构造内部类对象" class="headerlink" title="13.构造内部类对象"></a>13.构造内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enclosingone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Enclosingone.Insideone obj1 = <span class="keyword">new</span> Enclosingone().new Insideone();</span><br><span class="line">	Enclosingone.Insideone obj2 = <span class="keyword">new</span> Enclosingone.Insideone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-序列化"><a href="#14-序列化" class="headerlink" title="14.序列化"></a>14.序列化</h4><p>声明为static和transient类型的数据不能被序列化,序列化的笔记参见[Java-note-序列化.md][5]</p>
<h4 id="15-Java的方法区"><a href="#15-Java的方法区" class="headerlink" title="15.Java的方法区"></a>15.Java的方法区</h4><p>与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</p>
<h4 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16.正则表达式"></a>16.正则表达式</h4><p><strong>次数符号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 0或多次</span><br><span class="line">+ 1或多次</span><br><span class="line">？0或1次</span><br><span class="line">&#123;n&#125; 恰n次</span><br><span class="line">&#123;n,m&#125; 从n到m次</span><br></pre></td></tr></table></figure></p>
<p><strong>其他符号</strong></p>
<p>符号    等价形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d		[0-9]</span><br><span class="line">\D      [^0-9]  </span><br><span class="line">\w 		[a-zA-Z_0-9]</span><br><span class="line">\W 		[^a-zA-Z_0-9]</span><br><span class="line">\s 		[\t\n\r\f]</span><br><span class="line">\S 		[^\t\n\r\f]</span><br><span class="line">. 		任何字符</span><br></pre></td></tr></table></figure></p>
<p><strong>边界匹配器</strong></p>
<p>行开头    ^<br>行结尾  $<br>单词边界 \b</p>
<p><strong>贪婪模式</strong>:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配</p>
<p><strong>环视</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符 				描述 					匹配对象</span><br><span class="line">.					单个任意字符			</span><br><span class="line">[...] 				字符组 					列出的任意字符</span><br><span class="line">[^...] 										未列出的任意字符</span><br><span class="line">^ 					caret 					行的起始位置</span><br><span class="line">$     				dollar 					行的结束位置</span><br><span class="line">\&lt;   										单词的起始位置</span><br><span class="line">\&gt; 											单词的结束位置</span><br><span class="line">\b   				单词边界</span><br><span class="line">\B 					非单词边界</span><br><span class="line">(?=Expression)		顺序肯定环视			成功,如果右边能够匹配</span><br><span class="line">(?!Expression)		顺序否定环视			成功,如果右边不能够匹配</span><br><span class="line">(?&lt;=Expression)		逆序肯定环视			成功,如果左边能够匹配</span><br><span class="line">(?&lt;!Expression) 	逆序否定环视			成功,如果左边不能够匹配</span><br></pre></td></tr></table></figure>
<p>举例:北京市(海定区)(朝阳区)(西城区)</p>
<p>Regex: .*(?=\()</p>
<p><strong>模式和匹配器的典型调用次序</strong></p>
<ol>
<li>把正则表达式编译到模式中<br>Pattern p = Pattern.compile(“a*b”);</li>
<li>创建给定输入与此模式的匹配器<br>Matcher m = p.matcher(“aaab”);</li>
<li>尝试将整个区域与此模式匹配<br>boolean b = m.matches();</li>
</ol>
<h4 id="17-Servlet-amp-JSP-amp-Tomcat"><a href="#17-Servlet-amp-JSP-amp-Tomcat" class="headerlink" title="17.Servlet &amp; JSP &amp; Tomcat"></a>17.Servlet &amp; JSP &amp; Tomcat</h4><p>17.1 Servlet继承实现结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Servlet (接口) 			--&gt;      init|service|destroy方法</span><br><span class="line">GenericServlet(抽象类)  --&gt;      与协议无关的Servlet</span><br><span class="line">HttpServlet(抽象类)		--&gt;		 实现了http协议</span><br><span class="line">自定义Servlet			--&gt;		 重写doGet/doPost</span><br></pre></td></tr></table></figure></p>
<p>17.2 编写Servlet的步骤</p>
<ol>
<li>继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
<li>在web.xml中注册servlet</li>
</ol>
<p>17.3 Servlet生命周期</p>
<ol>
<li><code>init</code>:仅执行一次,负责装载servlet时初始化servlet对象</li>
<li><code>service</code>:核心方法,一般get/post两种方式</li>
<li><code>destroy</code>:停止并卸载servlet,释放资源</li>
</ol>
<p>17.4 过程</p>
<ol>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法</li>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service</li>
<li>加载和实例化、初始化、处理请求、服务结束</li>
</ol>
<p>17.5 doPost方法要抛出的异常:ServletExcception、IOException</p>
<p>17.6 Servlet容器装载Servlet</p>
<ol>
<li>web.xml中配置load-on-startup启动时装载</li>
<li>客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后,重新装载Servlet</li>
</ol>
<p>17.7 HttpServlet容器响应web客户请求流程</p>
<ol>
<li>Web客户向servlet容器发出http请求</li>
<li>servlet容器解析Web客户的http请求</li>
<li>servlet容器创建一个HttpRequest对象,封装http请求信息</li>
<li>servlet容器创建一个HttpResponse对象</li>
<li>servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象</li>
<li>HttpServlet调用httprequest的有关方法,获取http请求信息</li>
<li>httpservlet调用httpresponse的有关方法,生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给web客户</li>
</ol>
<p>17.8 HttpServletRequest完成的功能</p>
<ol>
<li>request.getCookie()</li>
<li>request.getHeader(String s)</li>
<li>request.getContextPath()</li>
</ol>
<p>17.9 HttpServletResponse完成的功能</p>
<ol>
<li>设http头</li>
<li>设置Cookie</li>
<li>输出返回数据</li>
</ol>
<p>17.10 <code>session</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession(boolean create)</span><br><span class="line">返回当前请求的会话</span><br></pre></td></tr></table></figure></p>
<p>17.11 JSP的前身就是Servlet</p>
<p>17.12 Tomcat容器的等级</p>
<p>Tomcat - <strong>Container</strong> - <strong>Engine</strong> - <strong>Host</strong> - <strong>Servlet</strong> - 多个Context(一个Context对应一个web工程)-Wrapper</p>
<p>17.13 Servlet与JSP九大内置对象的关系</p>
<p>JSP对象                 怎样获得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. out				-&gt;		response.getWriter</span><br><span class="line">2. request 		-&gt;		Service方法中的req参数</span><br><span class="line">3. response 		-&gt;		Service方法中的resp参数</span><br><span class="line">4. session 		-&gt;		request.getSession</span><br><span class="line">5. application 	-&gt;		getServletContext</span><br><span class="line">6. exception 		-&gt;		Throwable</span><br><span class="line">7. page  			-&gt;		this</span><br><span class="line">8. pageContext  	-&gt;		PageContext</span><br><span class="line">9. Config 			-&gt;		getServletConfig</span><br></pre></td></tr></table></figure></p>
<p>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。</p>
<h4 id="18-struts"><a href="#18-struts" class="headerlink" title="18.struts"></a>18.struts</h4><ol>
<li>struts可进行文件上传</li>
<li>struts基于MVC模式</li>
<li>struts让流程结构更清晰</li>
<li>struts有许多action类,会增加类文件数目</li>
</ol>
<h4 id="19-Hibernate的7大鼓励措施"><a href="#19-Hibernate的7大鼓励措施" class="headerlink" title="19.Hibernate的7大鼓励措施"></a>19.Hibernate的7大鼓励措施</h4><ol>
<li>尽量使用many-to-one,避免使用单项one-to-many</li>
<li>灵活使用单项one-to-many</li>
<li>不用一对一,使用多对一代替一对一</li>
<li>配置对象缓存,不使用集合对象</li>
<li>一对多使用bag,多对一使用set</li>
<li>继承使用显示多态</li>
<li>消除大表,使用二级缓存</li>
</ol>
<h4 id="20-JVM"><a href="#20-JVM" class="headerlink" title="20.JVM"></a>20.JVM</h4><p>20.1 JVM内存配置参数</p>
<ol>
<li>-Xmx:最大堆大小</li>
<li>-Xms:初始堆大小(最小内存值)</li>
<li>-Xmn:年轻代大小</li>
<li>-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</li>
<li>-Xss栈容量</li>
<li>-XX:+PrintGC 输出GC日志</li>
<li>-XX:+PrintGCDetails 输出GC的详细日志</li>
</ol>
<p>20.2 JVM内存结构</p>
<ol>
<li>堆:Eden、Survivor、old 线程共享</li>
<li>方法区(非堆):持久代,代码缓存,线程共享</li>
<li>JVM栈:中间结果,局部变量,线程隔离</li>
<li>本地栈:本地方法(非Java代码)</li>
<li>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址</li>
<li>注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分)</li>
</ol>
<h4 id="21-面向对象的五大基本原则-solid"><a href="#21-面向对象的五大基本原则-solid" class="headerlink" title="21.面向对象的五大基本原则(solid)"></a>21.面向对象的五大基本原则(solid)</h4><ol>
<li><p>S单一职责<code>SRP</code>:Single-Responsibility Principle<br>一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。</p>
</li>
<li><p>O开放封闭原则<code>OCP</code>:Open-Closed Principle<br>软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭</p>
</li>
<li><p>L里氏替换原则<code>LSP</code>:Liskov-Substitution Principle<br>子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。</p>
</li>
<li><p>I接口隔离原则<code>ISP</code>:Interface-Segregation Principle<br>使用多个小的接口,而不是一个大的总接口</p>
</li>
<li><p>D依赖倒置原则<code>DIP</code>:Dependency-Inversion Principle<br>依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</p>
</li>
</ol>
<h5 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h5><ol>
<li>封装变化</li>
<li>少用继承 多用组合</li>
<li>针对接口编程 不针对实现编程</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>类应该对扩展开发 对修改封闭（开闭OCP原则）</li>
<li>依赖抽象，不要依赖于具体类（依赖倒置DIP原则）</li>
<li><p>密友原则：只和朋友交谈（最少知识原则）</p>
<p>说明：将方法调用保持在界限内，只调用属于以下范围的方法：<br>该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象</p>
</li>
<li><p>别找我（调用我） 我会找你（调用你）（好莱坞原则）</p>
</li>
<li>一个类只有一个引起它变化的原因（单一职责SRP原则）</li>
</ol>
<h4 id="22-null可以被强制转型为任意类型的对象。"><a href="#22-null可以被强制转型为任意类型的对象。" class="headerlink" title="22.null可以被强制转型为任意类型的对象。"></a>22.null可以被强制转型为任意类型的对象。</h4><h4 id="23-代码执行次序"><a href="#23-代码执行次序" class="headerlink" title="23.代码执行次序"></a>23.代码执行次序</h4><ol>
<li>多个静态成员变量,静态代码块按顺序执行</li>
<li>单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法</li>
<li>构造块在每一次创建对象时执行</li>
<li>涉及父类和子类的初始化过程<br>a.初始化父类中的静态成员变量和静态代码块<br> b.初始化子类中的静态成员变量和静态代码块<br> c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖)<br> d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法</li>
</ol>
<h4 id="24-红黑树"><a href="#24-红黑树" class="headerlink" title="24.红黑树"></a>24.红黑树</h4><p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： <strong>若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；</strong>它的左、右子树也分别为二叉搜索树。</p>
<p><strong>红黑树</strong>的定义:满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>黑高</p>
<p>从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。<br>红黑树的黑高为其根结点的黑高。</p>
<p>其他</p>
<ul>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<h4 id="25-排序"><a href="#25-排序" class="headerlink" title="25.排序"></a>25.排序</h4><ul>
<li><p>稳定排序:插入排序、冒泡排序、归并排序、基数排序</p>
</li>
<li><p>插入排序[稳定]<br>适用于小数组,数组已排好序或接近于排好序速度将会非常快<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>归并排序[稳定]<br>采用分治法<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>冒泡排序[稳定]<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>基数排序 分配+收集[稳定]<br>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
</li>
<li><p>树排序<br>应用：TreeSet的add方法、TreeMap的put方法<br>不支持相同元素,没有稳定性问题<br>复杂度：平均最差O(nlogn)</p>
</li>
<li><p>堆排序(就地排序)<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>快速排序<br>复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]<br>栈空间0(lgn) - O(n)</p>
</li>
<li><p>选择排序<br>复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>希尔排序<br>复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1)</p>
</li>
</ul>
<h4 id="26-查找与散列"><a href="#26-查找与散列" class="headerlink" title="26.查找与散列"></a>26.查找与散列</h4><p>26.1 散列函数设计</p>
<ul>
<li><p>直接定址法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用</span><br><span class="line"></span><br><span class="line">* 除留余数法:```f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>DJBX33A算法(time33哈希算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">平方取中法 折叠法 更多....</span><br><span class="line"></span><br><span class="line">26.2 冲突处理</span><br><span class="line"></span><br><span class="line">闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中</span><br><span class="line"></span><br><span class="line">- 线性探测:易产生堆积现象(基地址不同堆积在一起)</span><br><span class="line">- 二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2...可以消除基本聚集</span><br><span class="line">- 随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集</span><br><span class="line">- 双散列:避免二次聚集</span><br><span class="line"></span><br><span class="line">开散列(链地址法):原地处理</span><br><span class="line"></span><br><span class="line">- 同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。</span><br><span class="line">- 优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间</span><br><span class="line"></span><br><span class="line">#### 27.枚举类</span><br><span class="line"></span><br><span class="line">JDK1.5出现 每个枚举值都需要调用一次构造函数</span><br><span class="line"></span><br><span class="line">#### 28.数组复制方法</span><br><span class="line"></span><br><span class="line">1. for逐一复制</span><br><span class="line">2. System.arraycopy() -&gt; 效率最高native方法</span><br><span class="line">3. Arrays.arrayOf() -&gt; 本质调用arraycopy</span><br><span class="line">4. clone方法 -&gt; 返回Object[],需要强制类型转换</span><br><span class="line"></span><br><span class="line">#### 29.多态</span><br><span class="line"></span><br><span class="line">1. Java通过方法重写和方法重载实现多态 </span><br><span class="line">2. 方法重写是指子类重写了父类的同名方法 </span><br><span class="line">3. 方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 </span><br><span class="line"></span><br><span class="line">#### 30.Java文件</span><br><span class="line"></span><br><span class="line">.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与</span><br><span class="line">文件名相同。而且这些类和写在多个文件中没有区别。</span><br><span class="line"></span><br><span class="line">#### 31.Java移位运算符</span><br><span class="line"></span><br><span class="line">java中有三种移位运算符</span><br><span class="line"></span><br><span class="line">1. &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0</span><br><span class="line">2. &gt;&gt; :带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1</span><br><span class="line">3. &gt;&gt;&gt; :无符号右移,忽略符号位,空位都以0补齐</span><br><span class="line"></span><br><span class="line">#### 32.形参&amp;实参</span><br><span class="line">1. 形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。</span><br><span class="line">2. 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。</span><br><span class="line">3. 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。</span><br><span class="line"></span><br><span class="line">#### 33.IO</span><br><span class="line">![](http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png)</span><br><span class="line"></span><br><span class="line">#### 34.局部变量为什么要初始化</span><br><span class="line"></span><br><span class="line">局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</span><br><span class="line"></span><br><span class="line">#### 35.JDK提供的用于并发编程的同步器</span><br><span class="line"></span><br><span class="line">1. Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</span><br><span class="line">2. CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。</span><br><span class="line">3. 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</span><br><span class="line"></span><br><span class="line">#### 36.Java类加载器</span><br><span class="line"></span><br><span class="line">一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： </span><br><span class="line"></span><br><span class="line">1. Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等</span><br><span class="line">2. Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等</span><br><span class="line">3. App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。 </span><br><span class="line">   classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。 </span><br><span class="line">   所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</span><br><span class="line"></span><br><span class="line">#### 37.Java语言的鲁棒性</span><br><span class="line"></span><br><span class="line">Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</span><br><span class="line"></span><br><span class="line">#### 38.Java语言特性</span><br><span class="line"></span><br><span class="line">1. Java致力于检查程序在编译和运行时的错误</span><br><span class="line">2. Java虚拟机实现了跨平台接口</span><br><span class="line">3. 类型检查帮助检查出许多开发早期出现的错误</span><br><span class="line">4. Java自己操纵内存减少了内存出错的可能性</span><br><span class="line">5. Java还实现了真数组，避免了覆盖数据的可能</span><br><span class="line"></span><br><span class="line">#### 39.Hibernate延迟加载</span><br><span class="line"></span><br><span class="line">1. Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） </span><br><span class="line">2. Hibernate3 提供了属性的延迟加载功能 </span><br><span class="line">   当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 </span><br><span class="line">3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 </span><br><span class="line">4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</span><br><span class="line"></span><br><span class="line">#### 40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。</span><br><span class="line"></span><br><span class="line">#### 41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。</span><br><span class="line"></span><br><span class="line">#### 42.Java语法糖</span><br><span class="line"></span><br><span class="line">1. Java7的switch用字符串 - hashcode方法 switch用于enum枚举</span><br><span class="line">2. 伪泛型 - List&lt; E&gt;原始类型</span><br><span class="line">3. 自动装箱拆箱 - Integer.valueOf和Integer.intValue</span><br><span class="line">4. foreach遍历 - Iterator迭代器实现</span><br><span class="line">5. 条件编译</span><br><span class="line">6. enum枚举类、内部类</span><br><span class="line">7. 可变参数 - 数组</span><br><span class="line">8. 断言语言</span><br><span class="line">9. try语句中定义和关闭资源</span><br><span class="line"></span><br><span class="line">#### 43.JVM工具</span><br><span class="line"></span><br><span class="line">命令行</span><br><span class="line"></span><br><span class="line">1. jps(jvm processor status)虚拟机进程状况工具</span><br><span class="line">2. jstat(jvm statistics monitoring)统计信息监视</span><br><span class="line">3. jinfo(configuration info for java)配置信息工具</span><br><span class="line">4. jmap(memory map for java)Java内存映射工具</span><br><span class="line">5. jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具</span><br><span class="line">6. jstack(Stack Trace for Java)Java堆栈跟踪工具</span><br><span class="line">7. HSDIS：JIT生成代码反汇编</span><br><span class="line"></span><br><span class="line">可视化</span><br><span class="line">1. JConsole(Java Monitoring and Management Console):Java监视与管理控制台</span><br><span class="line">2. VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具       </span><br><span class="line"></span><br><span class="line">#### 44.内部类为什么可以访问外部类的私有属性</span><br><span class="line"></span><br><span class="line">在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。</span><br><span class="line"></span><br><span class="line">当内部类调用外部类的私有属性时，其真正的执行是调用了编译器生成的属性的静态方法（即acess$0,access$1等）来获取这些属性值。这一切都是编译器的特殊处理。</span><br><span class="line"></span><br><span class="line">外部类可以通过内部类的实例获取私有属性x的操作.</span><br><span class="line"></span><br><span class="line">#### 45.如何让内部类私有成员不被外部访问</span><br><span class="line"></span><br><span class="line">使用匿名内部类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class PrivateToOuter &#123;</span><br><span class="line">  Runnable mRunnable = new Runnable()&#123;</span><br><span class="line">      private int x=10;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      PrivateToOuter p = new PrivateToOuter();</span><br><span class="line">      //System.out.println(&quot;anonymous class private filed= &quot;+ p.mRunnable.x); //not allowed</span><br><span class="line">      p.mRunnable.run(); // allowed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>由于mRunnable对象的类型为Runnable，而不是匿名内部类的类型（我们无法正常拿到），而Runanble中没有x这个属性，所以mRunnable.x是不被允许的。</p>
<h4 id="46-Java匿名内部类访问外部变量，为何需被标志为final？"><a href="#46-Java匿名内部类访问外部变量，为何需被标志为final？" class="headerlink" title="46. Java匿名内部类访问外部变量，为何需被标志为final？"></a>46. Java匿名内部类访问外部变量，为何需被标志为final？</h4><ul>
<li>这要从闭包说起，匿名内部类和外部方法形成了一个闭包，因此，匿名内部类能够访问外部方法的变量，看起来是一种“天经地义”的事情，Java语言当然也需要实现这种特性，但是这里遇到了一个问题。</li>
<li>匿名内部类的生命周期可能比外部的类要长，因此访问外部局部变量有可能是访问不到的。</li>
<li>那怎么办呢？Java语言为了实现这种特性， 只好将外部的局部变量偷偷的赋值了一份给匿名内部类。那这样匿名内部类就可以肆无忌惮的访问外部局部变量了。</li>
<li>问题又来了，这种通过赋值的形式有一个缺陷，匿名内部类不可以修改“原来的局部变量”，因为是一份“复制品”，修改复制品对原变量没什么影响啊。</li>
<li>那怎么办？ Java语言干脆强制要求被匿名内部类访问的外部局部变量必须是final的，什么意思呢？就是“一刀切”，不让修改了。</li>
</ul>
<h4 id="47-非静态内部类为什么不能有静态成员"><a href="#47-非静态内部类为什么不能有静态成员" class="headerlink" title="47. 非静态内部类为什么不能有静态成员"></a>47. 非静态内部类为什么不能有静态成员</h4><ul>
<li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li>
<li>要想使用某个类的static属性和方法，那么这个类必须要加载到虚拟机- 中。</li>
<li>非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</li>
</ul>
<p>在外部类并没有实例化，内部类还没有加载，这时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，这明显是矛盾的。</p>
<p>所以非静态内部类不能有静态成员变量或静态方法。</p>
<h4 id="48-手写实现二分查找"><a href="#48-手写实现二分查找" class="headerlink" title="48. 手写实现二分查找"></a>48. 手写实现二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;			<span class="comment">//初始中间位置</span></span><br><span class="line">	<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> middle;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/10/job2018/" rel="next" title="2018年年底Android悲催的面试之路">
                <i class="fa fa-chevron-left"></i> 2018年年底Android悲催的面试之路
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/default_avatar.jpg" alt="Mikee">
          <p class="site-author-name" itemprop="name">Mikee</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java面试题"><span class="nav-number">1.</span> <span class="nav-text">Java面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象的三个特征"><span class="nav-number">1.0.1.</span> <span class="nav-text">面向对象的三个特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多态的好处"><span class="nav-number">1.0.2.</span> <span class="nav-text">多态的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码中如何实现多态"><span class="nav-number">1.0.3.</span> <span class="nav-text">代码中如何实现多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机是如何实现多态的"><span class="nav-number">1.0.4.</span> <span class="nav-text">虚拟机是如何实现多态的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口的意义"><span class="nav-number">1.0.5.</span> <span class="nav-text">接口的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类的意义"><span class="nav-number">1.0.6.</span> <span class="nav-text">抽象类的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口和抽象类的区别"><span class="nav-number">1.0.7.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#父类的静态方法能否被子类重写"><span class="nav-number">1.0.8.</span> <span class="nav-text">父类的静态方法能否被子类重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是不可变对象"><span class="nav-number">1.0.9.</span> <span class="nav-text">什么是不可变对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量和实例变量的区别"><span class="nav-number">1.0.10.</span> <span class="nav-text">静态变量和实例变量的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#能否创建一个包含可变对象的不可变对象"><span class="nav-number">1.0.11.</span> <span class="nav-text">能否创建一个包含可变对象的不可变对象?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-创建对象的几种方式"><span class="nav-number">1.0.12.</span> <span class="nav-text">java 创建对象的几种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch中能否使用string做参数"><span class="nav-number">1.0.13.</span> <span class="nav-text">switch中能否使用string做参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch能否作用在byte-long上"><span class="nav-number">1.0.14.</span> <span class="nav-text">switch能否作用在byte,long上?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-s1-”ab”-String-s2-”a”-”b”-String-s3-”a”-String-s4-”b”-s5-s3-s4请问s5-s2返回什么"><span class="nav-number">1.0.15.</span> <span class="nav-text">String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你对String对象的intern-熟悉么"><span class="nav-number">1.0.16.</span> <span class="nav-text">你对String对象的intern()熟悉么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object中有哪些公共方法"><span class="nav-number">1.0.17.</span> <span class="nav-text">Object中有哪些公共方法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java当中的四种引用"><span class="nav-number">1.0.18.</span> <span class="nav-text">java当中的四种引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakReference与SoftReference的区别"><span class="nav-number">1.0.19.</span> <span class="nav-text">WeakReference与SoftReference的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要有不同的引用类型"><span class="nav-number">1.0.20.</span> <span class="nav-text">为什么要有不同的引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java中-和eqauls-的区别-equals-和hashcode的区别"><span class="nav-number">1.0.21.</span> <span class="nav-text">java中==和eqauls()的区别,equals()和hashcode的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-和hashcode-的联系"><span class="nav-number">1.0.22.</span> <span class="nav-text">equals()和hashcode()的联系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a-hashCode-有什么用-与a-equals-b-有什么关系"><span class="nav-number">1.0.23.</span> <span class="nav-text">a.hashCode()有什么用?与a.equals(b)有什么关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有没有可能两个不相等的对象有相同的hashcode"><span class="nav-number">1.0.24.</span> <span class="nav-text">有没有可能两个不相等的对象有相同的hashcode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可以在hashcode中使用随机数字吗"><span class="nav-number">1.0.25.</span> <span class="nav-text">可以在hashcode中使用随机数字吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a-b与a-equals-b-有什么区别"><span class="nav-number">1.0.26.</span> <span class="nav-text">a==b与a.equals(b)有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-0-1-0-3返回值是什么"><span class="nav-number">1.0.27.</span> <span class="nav-text">3*0.1==0.3返回值是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a-a-b与a-b有什么区别吗"><span class="nav-number">1.0.28.</span> <span class="nav-text">a=a+b与a+=b有什么区别吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#short-s1-1-s1-s1-1-该段代码是否有错-有的话怎么改？"><span class="nav-number">1.0.29.</span> <span class="nav-text">short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#short-s1-1-s1-1-该段代码是否有错-有的话怎么改？"><span class="nav-number">1.0.30.</span> <span class="nav-text">short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#amp-和-amp-amp-的区别"><span class="nav-number">1.0.31.</span> <span class="nav-text">&amp; 和 &amp;&amp;的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个-java文件内部可以有类-非内部类"><span class="nav-number">1.0.32.</span> <span class="nav-text">一个.java文件内部可以有类?(非内部类)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何正确的退出多层嵌套循环"><span class="nav-number">1.0.33.</span> <span class="nav-text">如何正确的退出多层嵌套循环.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类的作用"><span class="nav-number">1.0.34.</span> <span class="nav-text">内部类的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final-finalize和finally的不同之处"><span class="nav-number">1.0.35.</span> <span class="nav-text">final,finalize和finally的不同之处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clone-是哪个类的方法"><span class="nav-number">1.0.36.</span> <span class="nav-text">clone()是哪个类的方法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#深拷贝和浅拷贝的区别是什么"><span class="nav-number">1.0.37.</span> <span class="nav-text">深拷贝和浅拷贝的区别是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static都有哪些用法"><span class="nav-number">1.0.38.</span> <span class="nav-text">static都有哪些用法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final有哪些用法"><span class="nav-number">1.0.39.</span> <span class="nav-text">final有哪些用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型相关"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java中int-char-long各占多少字节"><span class="nav-number">1.1.1.</span> <span class="nav-text">java中int char,long各占多少字节?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64位的JVM当中-int的长度是多少"><span class="nav-number">1.1.2.</span> <span class="nav-text">64位的JVM当中,int的长度是多少?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int和Integer的区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">int和Integer的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-和Integer谁占用的内存更多"><span class="nav-number">1.1.4.</span> <span class="nav-text">int 和Integer谁占用的内存更多?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-StringBuffer和StringBuilder区别"><span class="nav-number">1.1.5.</span> <span class="nav-text">String,StringBuffer和StringBuilder区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String和StringBuffer"><span class="nav-number">1.1.6.</span> <span class="nav-text">String和StringBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer和StringBuilder"><span class="nav-number">1.1.7.</span> <span class="nav-text">StringBuffer和StringBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是编译器常量-使用它有什么风险"><span class="nav-number">1.1.8.</span> <span class="nav-text">什么是编译器常量?使用它有什么风险?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java当中使用什么类型表示价格比较好"><span class="nav-number">1.1.9.</span> <span class="nav-text">java当中使用什么类型表示价格比较好?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何将byte转为String"><span class="nav-number">1.1.10.</span> <span class="nav-text">如何将byte转为String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可以将int强转为byte类型么-会产生什么问题"><span class="nav-number">1.1.11.</span> <span class="nav-text">可以将int强转为byte类型么?会产生什么问题?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于垃圾回收"><span class="nav-number">1.2.</span> <span class="nav-text">关于垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#你知道哪些垃圾回收算法"><span class="nav-number">1.2.1.</span> <span class="nav-text">你知道哪些垃圾回收算法?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何判断一个对象是否应该被回收"><span class="nav-number">1.2.2.</span> <span class="nav-text">如何判断一个对象是否应该被回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单的解释一下垃圾回收"><span class="nav-number">1.2.3.</span> <span class="nav-text">简单的解释一下垃圾回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用System-gc-会发生什么"><span class="nav-number">1.2.4.</span> <span class="nav-text">调用System.gc()会发生什么?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-线程相关"><span class="nav-number">1.3.</span> <span class="nav-text">进程,线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#说说进程-线程-协程之间的区别"><span class="nav-number">1.3.1.</span> <span class="nav-text">说说进程,线程,协程之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你了解守护线程吗-它和非守护线程有什么区别"><span class="nav-number">1.3.2.</span> <span class="nav-text">你了解守护线程吗?它和非守护线程有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是多线程上下文切换"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是多线程上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建两种线程的方式-他们有什么区别"><span class="nav-number">1.3.4.</span> <span class="nav-text">创建两种线程的方式?他们有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread类中的start-和run-方法有什么区别"><span class="nav-number">1.3.5.</span> <span class="nav-text">Thread类中的start()和run()方法有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么检测一个线程是否持有对象监视器"><span class="nav-number">1.3.6.</span> <span class="nav-text">怎么检测一个线程是否持有对象监视器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runnable和Callable的区别"><span class="nav-number">1.3.7.</span> <span class="nav-text">Runnable和Callable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么导致线程阻塞"><span class="nav-number">1.3.8.</span> <span class="nav-text">什么导致线程阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-notify-和suspend-resume-之间的区别"><span class="nav-number">1.3.9.</span> <span class="nav-text">wait(),notify()和suspend(),resume()之间的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生死锁的条件"><span class="nav-number">1.3.10.</span> <span class="nav-text">产生死锁的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><span class="nav-number">1.3.11.</span> <span class="nav-text">为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><span class="nav-number">1.3.12.</span> <span class="nav-text">wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-与sleep-的区别"><span class="nav-number">1.3.13.</span> <span class="nav-text">wait()与sleep()的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么wait-nofity和nofityAll这些方法不放在Thread类当中"><span class="nav-number">1.3.14.</span> <span class="nav-text">为什么wait,nofity和nofityAll这些方法不放在Thread类当中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么唤醒一个阻塞的线程"><span class="nav-number">1.3.15.</span> <span class="nav-text">怎么唤醒一个阻塞的线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是多线程的上下文切换"><span class="nav-number">1.3.16.</span> <span class="nav-text">什么是多线程的上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized和ReentrantLock的区别"><span class="nav-number">1.3.17.</span> <span class="nav-text">synchronized和ReentrantLock的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask是什么"><span class="nav-number">1.3.18.</span> <span class="nav-text">FutureTask是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个线程如果出现了运行时异常怎么办"><span class="nav-number">1.3.19.</span> <span class="nav-text">一个线程如果出现了运行时异常怎么办?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java当中有哪几种锁"><span class="nav-number">1.3.20.</span> <span class="nav-text">Java当中有哪几种锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何在两个线程间共享数据"><span class="nav-number">1.3.21.</span> <span class="nav-text">如何在两个线程间共享数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何正确的使用wait-使用if还是while"><span class="nav-number">1.3.22.</span> <span class="nav-text">如何正确的使用wait()?使用if还是while?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是线程局部变量ThreadLocal"><span class="nav-number">1.3.23.</span> <span class="nav-text">什么是线程局部变量ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLoal的作用是什么"><span class="nav-number">1.3.24.</span> <span class="nav-text">ThreadLoal的作用是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者消费者模型的作用是什么"><span class="nav-number">1.3.25.</span> <span class="nav-text">生产者消费者模型的作用是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写一个生产者-消费者队列"><span class="nav-number">1.3.26.</span> <span class="nav-text">写一个生产者-消费者队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用阻塞队列来实现"><span class="nav-number">1.3.27.</span> <span class="nav-text">使用阻塞队列来实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用wait-notify来实现"><span class="nav-number">1.3.28.</span> <span class="nav-text">使用wait-notify来实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果你提交任务时，线程池队列已满，这时会发生什么"><span class="nav-number">1.3.29.</span> <span class="nav-text">如果你提交任务时，线程池队列已满，这时会发生什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要使用线程池"><span class="nav-number">1.3.30.</span> <span class="nav-text">为什么要使用线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java中用到的线程调度算法是什么"><span class="nav-number">1.3.31.</span> <span class="nav-text">java中用到的线程调度算法是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-sleep-0-的作用是什么"><span class="nav-number">1.3.32.</span> <span class="nav-text">Thread.sleep(0)的作用是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是CAS"><span class="nav-number">1.3.33.</span> <span class="nav-text">什么是CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是乐观锁和悲观锁"><span class="nav-number">1.3.34.</span> <span class="nav-text">什么是乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap的并发度是什么"><span class="nav-number">1.3.35.</span> <span class="nav-text">ConcurrentHashMap的并发度是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap的工作原理"><span class="nav-number">1.3.36.</span> <span class="nav-text">ConcurrentHashMap的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk-1-6"><span class="nav-number">1.3.37.</span> <span class="nav-text">jdk 1.6:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk-1-8"><span class="nav-number">1.3.38.</span> <span class="nav-text">jdk 1.8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier和CountDownLatch区别"><span class="nav-number">1.3.39.</span> <span class="nav-text">CyclicBarrier和CountDownLatch区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java中的-操作符线程安全么"><span class="nav-number">1.3.40.</span> <span class="nav-text">java中的++操作符线程安全么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你有哪些多线程开发良好的实践"><span class="nav-number">1.3.41.</span> <span class="nav-text">你有哪些多线程开发良好的实践?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于volatile关键字"><span class="nav-number">1.4.</span> <span class="nav-text">关于volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可以创建Volatile数组吗"><span class="nav-number">1.4.1.</span> <span class="nav-text">可以创建Volatile数组吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile能使得一个非原子操作变成原子操作吗"><span class="nav-number">1.4.2.</span> <span class="nav-text">volatile能使得一个非原子操作变成原子操作吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile类型变量提供什么保证"><span class="nav-number">1.4.3.</span> <span class="nav-text">volatile类型变量提供什么保证?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于集合"><span class="nav-number">1.5.</span> <span class="nav-text">关于集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中的集合及其继承关系"><span class="nav-number">1.5.1.</span> <span class="nav-text">Java中的集合及其继承关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll-方法和remove-方法区别"><span class="nav-number">1.5.2.</span> <span class="nav-text">poll()方法和remove()方法区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashMap和PriorityQueue的区别"><span class="nav-number">1.5.3.</span> <span class="nav-text">LinkedHashMap和PriorityQueue的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakHashMap与HashMap的区别是什么"><span class="nav-number">1.5.4.</span> <span class="nav-text">WeakHashMap与HashMap的区别是什么?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList和LinkedList的区别"><span class="nav-number">1.5.5.</span> <span class="nav-text">ArrayList和LinkedList的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList和Array有什么区别"><span class="nav-number">1.5.6.</span> <span class="nav-text">ArrayList和Array有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList和HashMap默认大小"><span class="nav-number">1.5.7.</span> <span class="nav-text">ArrayList和HashMap默认大小?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparator和Comparable的区别"><span class="nav-number">1.5.8.</span> <span class="nav-text">Comparator和Comparable的区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何实现集合排序"><span class="nav-number">1.5.9.</span> <span class="nav-text">如何实现集合排序?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何打印数组内容"><span class="nav-number">1.5.10.</span> <span class="nav-text">如何打印数组内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList的是单向链表还是双向"><span class="nav-number">1.5.11.</span> <span class="nav-text">LinkedList的是单向链表还是双向?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap是实现原理"><span class="nav-number">1.5.12.</span> <span class="nav-text">TreeMap是实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历ArrayList时如何正确移除一个元素"><span class="nav-number">1.5.13.</span> <span class="nav-text">遍历ArrayList时如何正确移除一个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是ArrayMap-它和HashMap有什么区别"><span class="nav-number">1.5.14.</span> <span class="nav-text">什么是ArrayMap?它和HashMap有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap的实现原理"><span class="nav-number">1.5.15.</span> <span class="nav-text">HashMap的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你了解Fail-Fast机制吗"><span class="nav-number">1.5.16.</span> <span class="nav-text">你了解Fail-Fast机制吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fail-fast和Fail-safe有什么区别"><span class="nav-number">1.5.17.</span> <span class="nav-text">Fail-fast和Fail-safe有什么区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于日期"><span class="nav-number">1.6.</span> <span class="nav-text">关于日期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SimpleDateFormat是线程安全的吗"><span class="nav-number">1.6.1.</span> <span class="nav-text">SimpleDateFormat是线程安全的吗?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何格式化日期"><span class="nav-number">1.6.2.</span> <span class="nav-text">如何格式化日期?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于异常"><span class="nav-number">1.7.</span> <span class="nav-text">关于异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单描述java异常体系"><span class="nav-number">1.7.1.</span> <span class="nav-text">简单描述java异常体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是异常链"><span class="nav-number">1.7.2.</span> <span class="nav-text">什么是异常链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throw和throws的区别"><span class="nav-number">1.7.3.</span> <span class="nav-text">throw和throws的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于序列化"><span class="nav-number">1.7.4.</span> <span class="nav-text">关于序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-中，Serializable-与-Externalizable-的区别"><span class="nav-number">1.7.5.</span> <span class="nav-text">Java 中，Serializable 与 Externalizable 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于JVM"><span class="nav-number">1.8.</span> <span class="nav-text">关于JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM特性"><span class="nav-number">1.8.1.</span> <span class="nav-text">JVM特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单解释一下类加载器"><span class="nav-number">1.8.2.</span> <span class="nav-text">简单解释一下类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简述堆和栈的区别"><span class="nav-number">1.8.3.</span> <span class="nav-text">简述堆和栈的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简述JVM内存分配"><span class="nav-number">1.8.4.</span> <span class="nav-text">简述JVM内存分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">1.9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java当中采用的是大端还是小端"><span class="nav-number">1.9.1.</span> <span class="nav-text">java当中采用的是大端还是小端?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML解析的几种方式和特点"><span class="nav-number">1.9.2.</span> <span class="nav-text">XML解析的几种方式和特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-7特性"><span class="nav-number">1.9.3.</span> <span class="nav-text">JDK 1.7特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-1-8特性"><span class="nav-number">1.9.4.</span> <span class="nav-text">JDK 1.8特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Maven和ANT有什么区别"><span class="nav-number">1.9.5.</span> <span class="nav-text">Maven和ANT有什么区别?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC最佳实践"><span class="nav-number">1.9.6.</span> <span class="nav-text">JDBC最佳实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO操作最佳实践"><span class="nav-number">1.9.7.</span> <span class="nav-text">IO操作最佳实践</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-常见概念"><span class="nav-number">2.</span> <span class="nav-text">Java 常见概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-HashMap和HashTable的区别"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.HashMap和HashTable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-java的线程安全类"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.java的线程安全类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-java集合框架"><span class="nav-number">2.0.3.</span> <span class="nav-text">3.java集合框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java垃圾回收机制"><span class="nav-number">2.0.4.</span> <span class="nav-text">4.Java垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-一些重要的关键字"><span class="nav-number">2.0.5.</span> <span class="nav-text">5.一些重要的关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-多线程-amp-并发-amp-同步-amp-锁"><span class="nav-number">2.0.6.</span> <span class="nav-text">6.多线程 &amp; 并发 &amp; 同步 &amp; 锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-接口与抽象类"><span class="nav-number">2.0.7.</span> <span class="nav-text">7.接口与抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Statement接口"><span class="nav-number">2.0.8.</span> <span class="nav-text">8.Statement接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-抽象类和最终类"><span class="nav-number">2.0.9.</span> <span class="nav-text">9.抽象类和最终类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-异常"><span class="nav-number">2.0.10.</span> <span class="nav-text">10.异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-this-amp-super"><span class="nav-number">2.0.11.</span> <span class="nav-text">11.this &amp; super</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-修饰符一览"><span class="nav-number">2.0.12.</span> <span class="nav-text">12.修饰符一览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-构造内部类对象"><span class="nav-number">2.0.13.</span> <span class="nav-text">13.构造内部类对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-序列化"><span class="nav-number">2.0.14.</span> <span class="nav-text">14.序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-Java的方法区"><span class="nav-number">2.0.15.</span> <span class="nav-text">15.Java的方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-正则表达式"><span class="nav-number">2.0.16.</span> <span class="nav-text">16.正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Servlet-amp-JSP-amp-Tomcat"><span class="nav-number">2.0.17.</span> <span class="nav-text">17.Servlet &amp; JSP &amp; Tomcat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-struts"><span class="nav-number">2.0.18.</span> <span class="nav-text">18.struts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-Hibernate的7大鼓励措施"><span class="nav-number">2.0.19.</span> <span class="nav-text">19.Hibernate的7大鼓励措施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-JVM"><span class="nav-number">2.0.20.</span> <span class="nav-text">20.JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-面向对象的五大基本原则-solid"><span class="nav-number">2.0.21.</span> <span class="nav-text">21.面向对象的五大基本原则(solid)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面向对象设计原则"><span class="nav-number">2.0.21.1.</span> <span class="nav-text">面向对象设计原则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-null可以被强制转型为任意类型的对象。"><span class="nav-number">2.0.22.</span> <span class="nav-text">22.null可以被强制转型为任意类型的对象。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-代码执行次序"><span class="nav-number">2.0.23.</span> <span class="nav-text">23.代码执行次序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-红黑树"><span class="nav-number">2.0.24.</span> <span class="nav-text">24.红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-排序"><span class="nav-number">2.0.25.</span> <span class="nav-text">25.排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-查找与散列"><span class="nav-number">2.0.26.</span> <span class="nav-text">26.查找与散列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-Java匿名内部类访问外部变量，为何需被标志为final？"><span class="nav-number">2.0.27.</span> <span class="nav-text">46. Java匿名内部类访问外部变量，为何需被标志为final？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-非静态内部类为什么不能有静态成员"><span class="nav-number">2.0.28.</span> <span class="nav-text">47. 非静态内部类为什么不能有静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-手写实现二分查找"><span class="nav-number">2.0.29.</span> <span class="nav-text">48. 手写实现二分查找</span></a></li></ol></li></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mikee</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
