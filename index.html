<!doctype html>



  


<html class="theme-next muse use-motion">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta property="og:type" content="website">
<meta property="og:title" content="Mikee的八度空间">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mikee的八度空间">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mikee的八度空间">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Mikee的八度空间 </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Mikee的八度空间</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/15/Java面试题/" itemprop="url">
                  Java面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-15T05:49:50+08:00" content="2018-12-15">
              2018-12-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h4><p>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.</p>
<h4 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h4><p>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p>
<ol>
<li>可替换性:多态对已存在代码具有可替换性.</li>
<li>可扩充性:增加新的子类不影响已经存在的类结构.</li>
<li>接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.</li>
<li>灵活性:</li>
<li>简化性:</li>
</ol>
<h4 id="代码中如何实现多态"><a href="#代码中如何实现多态" class="headerlink" title="代码中如何实现多态"></a>代码中如何实现多态</h4><p>实现多态主要有以下三种方式:</p>
<ol>
<li>接口实现</li>
<li>继承父类重写方法</li>
<li>同一类中进行方法重载</li>
</ol>
<h4 id="虚拟机是如何实现多态的"><a href="#虚拟机是如何实现多态的" class="headerlink" title="虚拟机是如何实现多态的"></a>虚拟机是如何实现多态的</h4><p>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.</p>
<h4 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h4><p>接口的意义用三个词就可以概括:规范,扩展,回调.</p>
<h4 id="抽象类的意义"><a href="#抽象类的意义" class="headerlink" title="抽象类的意义"></a>抽象类的意义</h4><p>抽象类的意义可以用三句话来概括:</p>
<ol>
<li>为其他子类提供一个公共的类型</li>
<li>封装子类中重复定义的内容</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的</li>
</ol>
<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><table>
<thead>
<tr>
<th>比较</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认方法</td>
<td>抽象类可以有默认的方法实现</td>
<td>java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td>实现方式</td>
<td>子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td>子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类中可以有构造器</td>
<td>接口中不能</td>
</tr>
<tr>
<td>和正常类区别</td>
<td>抽象类不能被实例化</td>
<td>接口则是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有public,protected和default等修饰</td>
<td>接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td>多继承</td>
<td>一个子类只能存在一个父类</td>
<td>一个子类可以存在多个接口</td>
</tr>
<tr>
<td>添加新方法</td>
<td>想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td>如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
</tbody>
</table>
<h4 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="headerlink" title="父类的静态方法能否被子类重写"></a>父类的静态方法能否被子类重写</h4><p>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.</p>
<h4 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a>什么是不可变对象</h4><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<h4 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别?"></a>静态变量和实例变量的区别?</h4><p>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.</p>
<h4 id="能否创建一个包含可变对象的不可变对象"><a href="#能否创建一个包含可变对象的不可变对象" class="headerlink" title="能否创建一个包含可变对象的不可变对象?"></a>能否创建一个包含可变对象的不可变对象?</h4><p>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.</p>
<h4 id="java-创建对象的几种方式"><a href="#java-创建对象的几种方式" class="headerlink" title="java 创建对象的几种方式"></a>java 创建对象的几种方式</h4><ol>
<li>采用new</li>
<li>通过反射</li>
<li>采用clone</li>
<li>通过序列化机制</li>
</ol>
<p>前2者都需要显式地调用构造方法.   造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.</p>
<h4 id="switch中能否使用string做参数"><a href="#switch中能否使用string做参数" class="headerlink" title="switch中能否使用string做参数"></a>switch中能否使用string做参数</h4><p>在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.</p>
<h4 id="switch能否作用在byte-long上"><a href="#switch能否作用在byte-long上" class="headerlink" title="switch能否作用在byte,long上?"></a>switch能否作用在byte,long上?</h4><p>可以用在byte上,但是不能用在long上.</p>
<h4 id="String-s1-”ab”-String-s2-”a”-”b”-String-s3-”a”-String-s4-”b”-s5-s3-s4请问s5-s2返回什么"><a href="#String-s1-”ab”-String-s2-”a”-”b”-String-s3-”a”-String-s4-”b”-s5-s3-s4请问s5-s2返回什么" class="headerlink" title="String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?"></a>String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?</h4><p> 返回false.在编译过程中,编译器会将s2直接优化为”ab”,会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String(“ab”);</p>
<h4 id="你对String对象的intern-熟悉么"><a href="#你对String对象的intern-熟悉么" class="headerlink" title="你对String对象的intern()熟悉么?"></a>你对String对象的intern()熟悉么?</h4><p> intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回.<br> 比如<br> String s1=”aa”;<br> String s2=s1.intern();<br> System.out.print(s1==s2);//返回false</p>
<h4 id="Object中有哪些公共方法"><a href="#Object中有哪些公共方法" class="headerlink" title="Object中有哪些公共方法?"></a>Object中有哪些公共方法?</h4><ol>
<li><code>equals()</code></li>
<li><code>clone()</code></li>
<li><code>getClass()</code></li>
<li><code>notify(),notifyAll(),wait()</code></li>
<li><code>toString</code></li>
</ol>
<h4 id="java当中的四种引用"><a href="#java当中的四种引用" class="headerlink" title="java当中的四种引用"></a>java当中的四种引用</h4><p>强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</p>
<ol>
<li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li>
<li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li>
<li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ol>
<p>更多了解参见<a href="http://blog.csdn.net/dd864140130/article/details/49885811" target="_blank" rel="noopener">深入对象引用</a></p>
<h4 id="WeakReference与SoftReference的区别"><a href="#WeakReference与SoftReference的区别" class="headerlink" title="WeakReference与SoftReference的区别?"></a>WeakReference与SoftReference的区别?</h4><p>这点在四种引用类型中已经做了解释,这里简单说明一下即可:<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</p>
<h4 id="为什么要有不同的引用类型"><a href="#为什么要有不同的引用类型" class="headerlink" title="为什么要有不同的引用类型"></a>为什么要有不同的引用类型</h4><p>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:</p>
<ol>
<li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li>
<li>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.</li>
</ol>
<h4 id="java中-和eqauls-的区别-equals-和hashcode的区别"><a href="#java中-和eqauls-的区别-equals-和hashcode的区别" class="headerlink" title="java中==和eqauls()的区别,equals()和hashcode的区别"></a>java中==和<code>eqauls()</code>的区别,<code>equals()</code>和<code>hashcode</code>的区别</h4><p>==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法</p>
<h4 id="equals-和hashcode-的联系"><a href="#equals-和hashcode-的联系" class="headerlink" title="equals()和hashcode()的联系"></a><code>equals()</code>和<code>hashcode()</code>的联系</h4><p><code>hashCode()</code>是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.<br>如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)</p>
<h4 id="a-hashCode-有什么用-与a-equals-b-有什么关系"><a href="#a-hashCode-有什么用-与a-equals-b-有什么关系" class="headerlink" title="a.hashCode()有什么用?与a.equals(b)有什么关系"></a>a.hashCode()有什么用?与a.equals(b)有什么关系</h4><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。</p>
<p>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.</p>
<h4 id="有没有可能两个不相等的对象有相同的hashcode"><a href="#有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="有没有可能两个不相等的对象有相同的hashcode"></a>有没有可能两个不相等的对象有相同的hashcode</h4><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立.</p>
<h4 id="可以在hashcode中使用随机数字吗"><a href="#可以在hashcode中使用随机数字吗" class="headerlink" title="可以在hashcode中使用随机数字吗?"></a>可以在hashcode中使用随机数字吗?</h4><p>不行，因为同一对象的 hashcode 值必须是相同的</p>
<h4 id="a-b与a-equals-b-有什么区别"><a href="#a-b与a-equals-b-有什么区别" class="headerlink" title="a==b与a.equals(b)有什么区别"></a>a==b与a.equals(b)有什么区别</h4><p>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h4 id="3-0-1-0-3返回值是什么"><a href="#3-0-1-0-3返回值是什么" class="headerlink" title="3*0.1==0.3返回值是什么"></a><code>3*0.1==0.3</code>返回值是什么</h4><p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h4 id="a-a-b与a-b有什么区别吗"><a href="#a-a-b与a-b有什么区别吗" class="headerlink" title="a=a+b与a+=b有什么区别吗?"></a>a=a+b与a+=b有什么区别吗?</h4><p>+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：<br>byte a = 127;<br>byte b = 127;<br>b = a + b; // error : cannot convert from int to byte<br>b += a; // ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p>
<h4 id="short-s1-1-s1-s1-1-该段代码是否有错-有的话怎么改？"><a href="#short-s1-1-s1-s1-1-该段代码是否有错-有的话怎么改？" class="headerlink" title="short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？"></a>short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</h4><p>有错误,short类型在进行运算时会自动提升为int类型,也就是说<code>s1+1</code>的运算结果是int类型.</p>
<h4 id="short-s1-1-s1-1-该段代码是否有错-有的话怎么改？"><a href="#short-s1-1-s1-1-该段代码是否有错-有的话怎么改？" class="headerlink" title="short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？"></a>short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？</h4><p>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型,所以没错.</p>
<h4 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp;的区别"></a>&amp; 和 &amp;&amp;的区别</h4><p>首先记住&amp;是位操作,而&amp;&amp;是逻辑运算符.另外需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name!=<span class="keyword">null</span>&amp;userName.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"erro"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码将会抛出空指针异常.</p>
<h4 id="一个-java文件内部可以有类-非内部类"><a href="#一个-java文件内部可以有类-非内部类" class="headerlink" title="一个.java文件内部可以有类?(非内部类)"></a>一个.java文件内部可以有类?(非内部类)</h4><p>只能有一个public公共类,但是可以有多个default修饰的类.</p>
<h4 id="如何正确的退出多层嵌套循环"><a href="#如何正确的退出多层嵌套循环" class="headerlink" title="如何正确的退出多层嵌套循环."></a>如何正确的退出多层嵌套循环.</h4><ol>
<li>使用标号和break;</li>
<li>通过在外层循环中添加标识符</li>
</ol>
<h4 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h4><p>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.</p>
<p>内部类提供了更好的封装,除了该外围类,其他类都不能访问</p>
<h4 id="final-finalize和finally的不同之处"><a href="#final-finalize和finally的不同之处" class="headerlink" title="final,finalize和finally的不同之处"></a>final,finalize和finally的不同之处</h4><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是<strong>在对象被回收之前调用的方法</strong>，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p>
<h4 id="clone-是哪个类的方法"><a href="#clone-是哪个类的方法" class="headerlink" title="clone()是哪个类的方法?"></a>clone()是哪个类的方法?</h4><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h4 id="深拷贝和浅拷贝的区别是什么"><a href="#深拷贝和浅拷贝的区别是什么" class="headerlink" title="深拷贝和浅拷贝的区别是什么?"></a>深拷贝和浅拷贝的区别是什么?</h4><p>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。</p>
<h4 id="static都有哪些用法"><a href="#static都有哪些用法" class="headerlink" title="static都有哪些用法?"></a>static都有哪些用法?</h4><p>几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.</p>
<p>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss PreCache&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//执行相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.</p>
<p>最后一种用法就是静态导包,即<code>import static</code>.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(Math.sin(20));传统做法</span></span><br><span class="line">        System.out.println(sin(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="final有哪些用法"><a href="#final有哪些用法" class="headerlink" title="final有哪些用法"></a>final有哪些用法</h4><p>final也是很多面试喜欢问的地方,能回答下以下三点就不错了:<br>1.被final修饰的类不可以被继承<br>2.被final修饰的方法不可以被重写<br>3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.<br>4.被final修饰的方法,JVM会尝试将其<strong>内联</strong>,以提高运行效率<br>5.被final修饰的常量,在编译阶段会存入常量池中.</p>
<p>回答出编译器对final域要遵守的两个重排序规则更好:<br>1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.<br>2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</p>
<hr>
<h3 id="数据类型相关"><a href="#数据类型相关" class="headerlink" title="数据类型相关"></a>数据类型相关</h3><h4 id="java中int-char-long各占多少字节"><a href="#java中int-char-long各占多少字节" class="headerlink" title="java中int char,long各占多少字节?"></a>java中int char,long各占多少字节?</h4><table>
<thead>
<tr>
<th>类型</th>
<th>位数</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>|float|4|32<br>|double|8|64|<br>|char|2|16|</p>
<h4 id="64位的JVM当中-int的长度是多少"><a href="#64位的JVM当中-int的长度是多少" class="headerlink" title="64位的JVM当中,int的长度是多少?"></a>64位的JVM当中,int的长度是多少?</h4><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h4 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h4><p>Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.</p>
<h4 id="int-和Integer谁占用的内存更多"><a href="#int-和Integer谁占用的内存更多" class="headerlink" title="int 和Integer谁占用的内存更多?"></a>int 和Integer谁占用的内存更多?</h4><p>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h4 id="String-StringBuffer和StringBuilder区别"><a href="#String-StringBuffer和StringBuilder区别" class="headerlink" title="String,StringBuffer和StringBuilder区别"></a>String,StringBuffer和StringBuilder区别</h4><p>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);<br>StringBuilder 字符串变量(线程不安全).</p>
<h4 id="String和StringBuffer"><a href="#String和StringBuffer" class="headerlink" title="String和StringBuffer"></a>String和StringBuffer</h4><p>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.</p>
<p>StringBuffer是对对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer.</p>
<p>但是需要注意现在JVM会对String拼接做一定的优化:<br><code>String s=“This is only ”+”simple”+”test”</code>会被虚拟机直接优化成<code>String s=“This is only simple test”</code>,此时就不存在拼接过程.</p>
<h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>StringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是jdk 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.</p>
<h4 id="什么是编译器常量-使用它有什么风险"><a href="#什么是编译器常量-使用它有什么风险" class="headerlink" title="什么是编译器常量?使用它有什么风险?"></a>什么是编译器常量?使用它有什么风险?</h4><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h4 id="java当中使用什么类型表示价格比较好"><a href="#java当中使用什么类型表示价格比较好" class="headerlink" title="java当中使用什么类型表示价格比较好?"></a>java当中使用什么类型表示价格比较好?</h4><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<h4 id="如何将byte转为String"><a href="#如何将byte转为String" class="headerlink" title="如何将byte转为String"></a>如何将byte转为String</h4><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<h4 id="可以将int强转为byte类型么-会产生什么问题"><a href="#可以将int强转为byte类型么-会产生什么问题" class="headerlink" title="可以将int强转为byte类型么?会产生什么问题?"></a>可以将int强转为byte类型么?会产生什么问题?</h4><p>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128</p>
<hr>
<h3 id="关于垃圾回收"><a href="#关于垃圾回收" class="headerlink" title="关于垃圾回收"></a>关于垃圾回收</h3><h4 id="你知道哪些垃圾回收算法"><a href="#你知道哪些垃圾回收算法" class="headerlink" title="你知道哪些垃圾回收算法?"></a>你知道哪些垃圾回收算法?</h4><p>垃圾回收从理论上非常容易理解,具体的方法有以下几种:</p>
<ol>
<li>标记-清除</li>
<li>标记-复制</li>
<li>标记-整理</li>
<li>分代回收<br>更详细的内容参见<a href="http://blog.csdn.net/dd864140130/article/details/50084471" target="_blank" rel="noopener">深入理解垃圾回收算法</a></li>
</ol>
<h4 id="如何判断一个对象是否应该被回收"><a href="#如何判断一个对象是否应该被回收" class="headerlink" title="如何判断一个对象是否应该被回收"></a>如何判断一个对象是否应该被回收</h4><p>这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.</p>
<h4 id="简单的解释一下垃圾回收"><a href="#简单的解释一下垃圾回收" class="headerlink" title="简单的解释一下垃圾回收"></a>简单的解释一下垃圾回收</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.</p>
<h4 id="调用System-gc-会发生什么"><a href="#调用System-gc-会发生什么" class="headerlink" title="调用System.gc()会发生什么?"></a>调用System.gc()会发生什么?</h4><p>通知GC开始工作,但是GC真正开始的时间不确定.</p>
<hr>
<h3 id="进程-线程相关"><a href="#进程-线程相关" class="headerlink" title="进程,线程相关"></a>进程,线程相关</h3><h4 id="说说进程-线程-协程之间的区别"><a href="#说说进程-线程-协程之间的区别" class="headerlink" title="说说进程,线程,协程之间的区别"></a>说说进程,线程,协程之间的区别</h4><p>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.</p>
<h4 id="你了解守护线程吗-它和非守护线程有什么区别"><a href="#你了解守护线程吗-它和非守护线程有什么区别" class="headerlink" title="你了解守护线程吗?它和非守护线程有什么区别"></a>你了解守护线程吗?它和非守护线程有什么区别</h4><p>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程</p>
<h4 id="什么是多线程上下文切换"><a href="#什么是多线程上下文切换" class="headerlink" title="什么是多线程上下文切换"></a>什么是多线程上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h4 id="创建两种线程的方式-他们有什么区别"><a href="#创建两种线程的方式-他们有什么区别" class="headerlink" title="创建两种线程的方式?他们有什么区别?"></a>创建两种线程的方式?他们有什么区别?</h4><p>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p>
<ol>
<li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li>
<li>类可能只要求可执行即可,因此继承整个Thread类的开销过大.</li>
</ol>
<h4 id="Thread类中的start-和run-方法有什么区别"><a href="#Thread类中的start-和run-方法有什么区别" class="headerlink" title="Thread类中的start()和run()方法有什么区别?"></a>Thread类中的start()和run()方法有什么区别?</h4><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h4 id="怎么检测一个线程是否持有对象监视器"><a href="#怎么检测一个线程是否持有对象监视器" class="headerlink" title="怎么检测一个线程是否持有对象监视器"></a>怎么检测一个线程是否持有对象监视器</h4><p>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p>
<h4 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h4><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务</p>
<h4 id="什么导致线程阻塞"><a href="#什么导致线程阻塞" class="headerlink" title="什么导致线程阻塞"></a>什么导致线程阻塞</h4><p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sleep()</td>
<td>sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td>
</tr>
<tr>
<td>suspend() 和 resume()</td>
<td>两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td>
</tr>
<tr>
<td>yield()</td>
<td>yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td>
</tr>
<tr>
<td>wait() 和 notify()</td>
<td>两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td>
</tr>
</tbody>
</table>
<h4 id="wait-notify-和suspend-resume-之间的区别"><a href="#wait-notify-和suspend-resume-之间的区别" class="headerlink" title="wait(),notify()和suspend(),resume()之间的区别"></a>wait(),notify()和suspend(),resume()之间的区别</h4><p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><p>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h4 id="为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h4><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<h4 id="wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h4><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>
<h4 id="wait-与sleep-的区别"><a href="#wait-与sleep-的区别" class="headerlink" title="wait()与sleep()的区别"></a>wait()与sleep()的区别</h4><p> 关于这两者已经在上面进行详细的说明,这里就做个概括好了:</p>
<ul>
<li>sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li>
<li>sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU</li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用</li>
</ul>
<h4 id="为什么wait-nofity和nofityAll这些方法不放在Thread类当中"><a href="#为什么wait-nofity和nofityAll这些方法不放在Thread类当中" class="headerlink" title="为什么wait,nofity和nofityAll这些方法不放在Thread类当中"></a>为什么wait,nofity和nofityAll这些方法不放在Thread类当中</h4><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h4 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a>怎么唤醒一个阻塞的线程</h4><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<h4 id="什么是多线程的上下文切换"><a href="#什么是多线程的上下文切换" class="headerlink" title="什么是多线程的上下文切换"></a>什么是多线程的上下文切换</h4><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p>
<h4 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么"></a>FutureTask是什么</h4><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>
<h4 id="一个线程如果出现了运行时异常怎么办"><a href="#一个线程如果出现了运行时异常怎么办" class="headerlink" title="一个线程如果出现了运行时异常怎么办?"></a>一个线程如果出现了运行时异常怎么办?</h4><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p>
<h4 id="Java当中有哪几种锁"><a href="#Java当中有哪几种锁" class="headerlink" title="Java当中有哪几种锁"></a>Java当中有哪几种锁</h4><ol>
<li>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</li>
<li>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</li>
<li>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁</li>
</ol>
<h4 id="如何在两个线程间共享数据"><a href="#如何在两个线程间共享数据" class="headerlink" title="如何在两个线程间共享数据"></a>如何在两个线程间共享数据</h4><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
<h4 id="如何正确的使用wait-使用if还是while"><a href="#如何正确的使用wait-使用if还是while" class="headerlink" title="如何正确的使用wait()?使用if还是while?"></a>如何正确的使用wait()?使用if还是while?</h4><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">   while (condition does not hold)</span><br><span class="line">     obj.wait(); // (Releases lock, and reacquires on wakeup)</span><br><span class="line">     ... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="什么是线程局部变量ThreadLocal"><a href="#什么是线程局部变量ThreadLocal" class="headerlink" title="什么是线程局部变量ThreadLocal"></a>什么是线程局部变量ThreadLocal</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h4 id="ThreadLoal的作用是什么"><a href="#ThreadLoal的作用是什么" class="headerlink" title="ThreadLoal的作用是什么?"></a>ThreadLoal的作用是什么?</h4><p>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.</p>
<h4 id="生产者消费者模型的作用是什么"><a href="#生产者消费者模型的作用是什么" class="headerlink" title="生产者消费者模型的作用是什么?"></a>生产者消费者模型的作用是什么?</h4><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>
<h4 id="写一个生产者-消费者队列"><a href="#写一个生产者-消费者队列" class="headerlink" title="写一个生产者-消费者队列"></a>写一个生产者-消费者队列</h4><p>可以通过阻塞队列实现,也可以通过wait-notify来实现.</p>
<h4 id="使用阻塞队列来实现"><a href="#使用阻塞队列来实现" class="headerlink" title="使用阻塞队列来实现"></a>使用阻塞队列来实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//消费者</span><br><span class="line">public class Producer implements Runnable&#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Producer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true)&#123;</span><br><span class="line">                Thread.sleep(1000);//模拟耗时</span><br><span class="line">                queue.put(produce());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int produce() &#123;</span><br><span class="line">        int n=new Random().nextInt(10000);</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; produce:&quot; + n);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//消费者</span><br><span class="line">public class Consumer implements Runnable &#123;</span><br><span class="line">    private final BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    public Consumer(BlockingQueue q)&#123;</span><br><span class="line">        this.queue=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);//模拟耗时</span><br><span class="line">                consume(queue.take());</span><br><span class="line">            &#125;catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void consume(Integer n) &#123;</span><br><span class="line">        System.out.println(&quot;Thread:&quot; + Thread.currentThread().getId() + &quot; consume:&quot; + n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(100);</span><br><span class="line">        Producer p=new Producer(queue);</span><br><span class="line">        Consumer c1=new Consumer(queue);</span><br><span class="line">        Consumer c2=new Consumer(queue);</span><br><span class="line"></span><br><span class="line">        new Thread(p).start();</span><br><span class="line">        new Thread(c1).start();</span><br><span class="line">        new Thread(c2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用wait-notify来实现"><a href="#使用wait-notify来实现" class="headerlink" title="使用wait-notify来实现"></a>使用wait-notify来实现</h4><p>该种方式应该最经典,这里就不做说明了</p>
<h4 id="如果你提交任务时，线程池队列已满，这时会发生什么"><a href="#如果你提交任务时，线程池队列已满，这时会发生什么" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发生什么"></a>如果你提交任务时，线程池队列已满，这时会发生什么</h4><p>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p>
<h4 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h4><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>
<h4 id="java中用到的线程调度算法是什么"><a href="#java中用到的线程调度算法是什么" class="headerlink" title="java中用到的线程调度算法是什么"></a>java中用到的线程调度算法是什么</h4><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h4 id="Thread-sleep-0-的作用是什么"><a href="#Thread-sleep-0-的作用是什么" class="headerlink" title="Thread.sleep(0)的作用是什么"></a>Thread.sleep(0)的作用是什么</h4><p>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>
<h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功</p>
<h4 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h4><p>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>
<p>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p>
<h4 id="ConcurrentHashMap的并发度是什么"><a href="#ConcurrentHashMap的并发度是什么" class="headerlink" title="ConcurrentHashMap的并发度是什么?"></a>ConcurrentHashMap的并发度是什么?</h4><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<h4 id="ConcurrentHashMap的工作原理"><a href="#ConcurrentHashMap的工作原理" class="headerlink" title="ConcurrentHashMap的工作原理"></a>ConcurrentHashMap的工作原理</h4><p>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.</p>
<h4 id="jdk-1-6"><a href="#jdk-1-6" class="headerlink" title="jdk 1.6:"></a>jdk 1.6:</h4><p>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。<br>具体实现:ConcurrentHashMap内部有一个Segment<k,v>数组,该Segment对象可以充当锁。Segment对象内部有一个HashEntry<k,v>数组，于是每个Segment可以守护若干个桶(HashEntry),每个桶又有可能是一个HashEntry连接起来的链表，存储发生碰撞的元素。<br>每个ConcurrentHashMap在默认并发级下会创建包含16个Segment对象的数组，每个数组有若干个桶，当我们进行put方法时，通过hash方法对key进行计算，得到hash值，找到对应的segment，然后对该segment进行加锁，然后调用segment的put方法进行存储操作，此时其他线程就不能访问当前的segment，但可以访问其他的segment对象，不会发生阻塞等待。</k,v></k,v></p>
<h4 id="jdk-1-8"><a href="#jdk-1-8" class="headerlink" title="jdk 1.8"></a>jdk 1.8</h4><p>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。</p>
<h4 id="CyclicBarrier和CountDownLatch区别"><a href="#CyclicBarrier和CountDownLatch区别" class="headerlink" title="CyclicBarrier和CountDownLatch区别"></a>CyclicBarrier和CountDownLatch区别</h4><p>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ul>
<li>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</li>
<li>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</li>
</ul>
<h4 id="java中的-操作符线程安全么"><a href="#java中的-操作符线程安全么" class="headerlink" title="java中的++操作符线程安全么?"></a>java中的++操作符线程安全么?</h4><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差</p>
<h4 id="你有哪些多线程开发良好的实践"><a href="#你有哪些多线程开发良好的实践" class="headerlink" title="你有哪些多线程开发良好的实践?"></a>你有哪些多线程开发良好的实践?</h4><ol>
<li>给线程命名</li>
<li>最小化同步范围</li>
<li>优先使用volatile</li>
<li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li>
<li>优先使用并发容器而非同步容器.</li>
<li>考虑使用线程池</li>
</ol>
<hr>
<h3 id="关于volatile关键字"><a href="#关于volatile关键字" class="headerlink" title="关于volatile关键字"></a>关于volatile关键字</h3><h4 id="可以创建Volatile数组吗"><a href="#可以创建Volatile数组吗" class="headerlink" title="可以创建Volatile数组吗?"></a>可以创建Volatile数组吗?</h4><p>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了</p>
<h4 id="volatile能使得一个非原子操作变成原子操作吗"><a href="#volatile能使得一个非原子操作变成原子操作吗" class="headerlink" title="volatile能使得一个非原子操作变成原子操作吗?"></a>volatile能使得一个非原子操作变成原子操作吗?</h4><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 <strong>Java 中读取 long 类型变量不是原子的</strong>，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是<strong>对一个 volatile 型的 long 或 double 变量的读写是原子</strong>。</p>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是<strong>64位宽</strong>，因此对这两种类型的读是分为两部分的，<strong>第一次读取第一个 32 位，然后再读剩下的 32 位</strong>，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为<strong>内存屏障会将其他所有写的值更新到缓存</strong>。</p>
<h4 id="volatile类型变量提供什么保证"><a href="#volatile类型变量提供什么保证" class="headerlink" title="volatile类型变量提供什么保证?"></a>volatile类型变量提供什么保证?</h4><p>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>
<hr>
<h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><h4 id="Java中的集合及其继承关系"><a href="#Java中的集合及其继承关系" class="headerlink" title="Java中的集合及其继承关系"></a>Java中的集合及其继承关系</h4><p>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:<br><img src="http://img.blog.csdn.net/20141105193133812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGQ4NjQxNDAxMzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述"></p>
<p>更多内容可见<a href="http://write.blog.csdn.net/postedit/40826423" target="_blank" rel="noopener">集合类总结</a></p>
<h4 id="poll-方法和remove-方法区别"><a href="#poll-方法和remove-方法区别" class="headerlink" title="poll()方法和remove()方法区别?"></a>poll()方法和remove()方法区别?</h4><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h4 id="LinkedHashMap和PriorityQueue的区别"><a href="#LinkedHashMap和PriorityQueue的区别" class="headerlink" title="LinkedHashMap和PriorityQueue的区别"></a>LinkedHashMap和PriorityQueue的区别</h4><p>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p>
<h4 id="WeakHashMap与HashMap的区别是什么"><a href="#WeakHashMap与HashMap的区别是什么" class="headerlink" title="WeakHashMap与HashMap的区别是什么?"></a>WeakHashMap与HashMap的区别是什么?</h4><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p>
<h4 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别?"></a>ArrayList和LinkedList的区别?</h4><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是<strong>双向循环链表，不支持随机访问</strong>。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>
<h4 id="ArrayList和Array有什么区别"><a href="#ArrayList和Array有什么区别" class="headerlink" title="ArrayList和Array有什么区别?"></a>ArrayList和Array有什么区别?</h4><ol>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的</li>
</ol>
<h4 id="ArrayList和HashMap默认大小"><a href="#ArrayList和HashMap默认大小" class="headerlink" title="ArrayList和HashMap默认大小?"></a>ArrayList和HashMap默认大小?</h4><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"> </span><br><span class="line"> //from HashMap.java JDK 7</span><br><span class="line"> static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>
<h4 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别?"></a>Comparator和Comparable的区别?</h4><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h4 id="如何实现集合排序"><a href="#如何实现集合排序" class="headerlink" title="如何实现集合排序?"></a>如何实现集合排序?</h4><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p>
<h4 id="如何打印数组内容"><a href="#如何打印数组内容" class="headerlink" title="如何打印数组内容"></a>如何打印数组内容</h4><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p>
<h4 id="LinkedList的是单向链表还是双向"><a href="#LinkedList的是单向链表还是双向" class="headerlink" title="LinkedList的是单向链表还是双向?"></a>LinkedList的是单向链表还是双向?</h4><p>双向循环列表,具体实现自行查阅源码.</p>
<h4 id="TreeMap是实现原理"><a href="#TreeMap是实现原理" class="headerlink" title="TreeMap是实现原理"></a>TreeMap是实现原理</h4><p>采用红黑树实现,具体实现自行查阅源码.</p>
<h4 id="遍历ArrayList时如何正确移除一个元素"><a href="#遍历ArrayList时如何正确移除一个元素" class="headerlink" title="遍历ArrayList时如何正确移除一个元素"></a>遍历ArrayList时如何正确移除一个元素</h4><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p>
<h4 id="什么是ArrayMap-它和HashMap有什么区别"><a href="#什么是ArrayMap-它和HashMap有什么区别" class="headerlink" title="什么是ArrayMap?它和HashMap有什么区别?"></a>什么是ArrayMap?它和HashMap有什么区别?</h4><p>ArrayMap是Android SDK中提供的,非Android开发者可以略过.<br>ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.<br>具体参考这篇文章:<a href="http://lvable.com/?p=217%5D" target="_blank" rel="noopener">ArrayMap VS HashMap</a></p>
<h4 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h4><p>1   HashMap概述：  HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>2   HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
<p>HashMap当中，存储最终数据的其实是一个HashMapEntry类型的数组：HashMapEntry<k, v="">[] table。</k,></p>
<p>而HashMapEntry对象其实是属于一种单向链表结构。</p>
<p>这样最终其实是构造了一种二维的结构。</p>
<p>我们看一下HashMapEntry类：</p>
<p>里面有四个元素，key,value,hash值以及指向的下一个节点的对象。</p>
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.</p>
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>
<h4 id="你了解Fail-Fast机制吗"><a href="#你了解Fail-Fast机制吗" class="headerlink" title="你了解Fail-Fast机制吗"></a>你了解Fail-Fast机制吗</h4><p>Fail-Fast即我们常说的快速失败,更多内容参看<a href="http://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">fail-fast机制</a></p>
<h4 id="Fail-fast和Fail-safe有什么区别"><a href="#Fail-fast和Fail-safe有什么区别" class="headerlink" title="Fail-fast和Fail-safe有什么区别"></a>Fail-fast和Fail-safe有什么区别</h4><p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<hr>
<h3 id="关于日期"><a href="#关于日期" class="headerlink" title="关于日期"></a>关于日期</h3><h4 id="SimpleDateFormat是线程安全的吗"><a href="#SimpleDateFormat是线程安全的吗" class="headerlink" title="SimpleDateFormat是线程安全的吗?"></a>SimpleDateFormat是线程安全的吗?</h4><p>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h4 id="如何格式化日期"><a href="#如何格式化日期" class="headerlink" title="如何格式化日期?"></a>如何格式化日期?</h4><p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<hr>
<h3 id="关于异常"><a href="#关于异常" class="headerlink" title="关于异常"></a>关于异常</h3><h4 id="简单描述java异常体系"><a href="#简单描述java异常体系" class="headerlink" title="简单描述java异常体系"></a>简单描述java异常体系</h4><p>相比没有人不了解异常体系,关于异常体系的更多信息可以见:<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a></p>
<h4 id="什么是异常链"><a href="#什么是异常链" class="headerlink" title="什么是异常链"></a>什么是异常链</h4><p>详情直接参见<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">白话异常机制</a>,不做解释了.</p>
<h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><p>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：<code>throw new IllegalArgumentException(“size must be multiple of 2″)</code>,<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<hr>
<h4 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h4><h4 id="Java-中，Serializable-与-Externalizable-的区别"><a href="#Java-中，Serializable-与-Externalizable-的区别" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别"></a>Java 中，Serializable 与 Externalizable 的区别</h4><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<hr>
<h3 id="关于JVM"><a href="#关于JVM" class="headerlink" title="关于JVM"></a>关于JVM</h3><h4 id="JVM特性"><a href="#JVM特性" class="headerlink" title="JVM特性"></a>JVM特性</h4><p>平台无关性.<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<h4 id="简单解释一下类加载器"><a href="#简单解释一下类加载器" class="headerlink" title="简单解释一下类加载器"></a>简单解释一下类加载器</h4><p>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,更多的内容参看<a href="http://blog.csdn.net/dd864140130/article/details/49817357" target="_blank" rel="noopener">深入理解JVM加载器</a></p>
<h4 id="简述堆和栈的区别"><a href="#简述堆和栈的区别" class="headerlink" title="简述堆和栈的区别"></a>简述堆和栈的区别</h4><p>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
<h4 id="简述JVM内存分配"><a href="#简述JVM内存分配" class="headerlink" title="简述JVM内存分配"></a>简述JVM内存分配</h4><ol>
<li>基本数据类型比变量和对象的引用都是在栈分配的</li>
<li>堆内存用来存放由new创建的对象和数组</li>
<li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li>
<li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li>
<li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li>
</ol>
<hr>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="java当中采用的是大端还是小端"><a href="#java当中采用的是大端还是小端" class="headerlink" title="java当中采用的是大端还是小端?"></a>java当中采用的是大端还是小端?</h4><p>默认为大端模式</p>
<h4 id="XML解析的几种方式和特点"><a href="#XML解析的几种方式和特点" class="headerlink" title="XML解析的几种方式和特点"></a>XML解析的几种方式和特点</h4><p>DOM,SAX,PULL三种解析方式:</p>
<ul>
<li>DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机</li>
<li>SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</li>
<li>PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</li>
</ul>
<h4 id="JDK-1-7特性"><a href="#JDK-1-7特性" class="headerlink" title="JDK 1.7特性"></a>JDK 1.7特性</h4><p>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(\&lt;>)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码</p>
<h4 id="JDK-1-8特性"><a href="#JDK-1-8特性" class="headerlink" title="JDK 1.8特性"></a>JDK 1.8特性</h4><p>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<h4 id="Maven和ANT有什么区别"><a href="#Maven和ANT有什么区别" class="headerlink" title="Maven和ANT有什么区别?"></a>Maven和ANT有什么区别?</h4><p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件.</p>
<h4 id="JDBC最佳实践"><a href="#JDBC最佳实践" class="headerlink" title="JDBC最佳实践"></a>JDBC最佳实践</h4><ul>
<li>优先使用批量操作来插入和更新数据</li>
<li>使用PreparedStatement来避免SQL漏洞</li>
<li>使用数据连接池</li>
<li>通过列名来获取结果集</li>
</ul>
<h4 id="IO操作最佳实践"><a href="#IO操作最佳实践" class="headerlink" title="IO操作最佳实践"></a>IO操作最佳实践</h4><ol>
<li>使用有缓冲的IO类,不要单独读取字节或字符</li>
<li>使用NIO和NIO 2或者AIO,而非BIO</li>
<li>在finally中关闭流</li>
<li>使用内存映射文件获取更快的IO</li>
</ol>
<h2 id="Java-常见概念"><a href="#Java-常见概念" class="headerlink" title="Java 常见概念"></a>Java 常见概念</h2><h4 id="1-HashMap和HashTable的区别"><a href="#1-HashMap和HashTable的区别" class="headerlink" title="1.HashMap和HashTable的区别"></a>1.HashMap和HashTable的区别</h4><ul>
<li>[x] HashMap去掉了contains方法</li>
<li>[x] HashTable是<strong>同步</strong>的(线程安全)</li>
<li>[x] HashMap允许空键值</li>
<li>[x] HashMap执行快速失败机制</li>
<li>[ ] <code>Fast-fail</code>机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException</li>
</ul>
<ul>
<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>
</ul>
<ul>
<li>Hashtable和HashMap有几个主要的不同：<strong>线程安全以及速度</strong>。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用<strong>ConcurrentHashMap</strong>吧。</li>
</ul>
<h4 id="2-java的线程安全类"><a href="#2-java的线程安全类" class="headerlink" title="2.java的线程安全类"></a>2.java的线程安全类</h4><p>Vector、Stack、HashTable、ConcurrentHashMap、Properties</p>
<h4 id="3-java集合框架"><a href="#3-java集合框架" class="headerlink" title="3.java集合框架"></a>3.java集合框架</h4><ul>
<li>Collection - List<ul>
<li>有顺序以线性方式存储,可以存放重复对象</li>
</ul>
</li>
<li>Collection - List - ArrayList<ul>
<li>数组方式存储数据　　索引数据快插入数据慢　　线程不安全</li>
</ul>
</li>
<li>Collection - List - LinkedList <ul>
<li>双向链表实现存储　　索引数据慢插入数度较快　　线程不安全（比安全性能好）</li>
</ul>
</li>
<li>Collection - List - Vector<ul>
<li>数组方式存储数据　　索引数据快插入数据慢　　线程安全</li>
</ul>
</li>
<li>Collection - List - Vector - Stack<ul>
<li>继承自Vector，实现一个后进先出的堆栈</li>
</ul>
</li>
<li>Collection - Set<ul>
<li>无顺序,不包含重复的元素</li>
</ul>
</li>
<li>Collection - Set - HashSet <ul>
<li>为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。  </li>
</ul>
</li>
<li>Collection - Set - TreeSet<ul>
<li>保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。  </li>
</ul>
</li>
<li>Collection - Set - LinkedHashSet<ul>
<li>具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</li>
</ul>
</li>
<li>Map<ul>
<li>键必须是唯一</li>
</ul>
</li>
<li>Map - HashMap<ul>
<li>HashMap:基于散列表的实现　　允许空键空值　　线程不安全　　(与Hashtable基本一致)</li>
</ul>
</li>
<li>Map - TreeMap<ul>
<li>TreeMap: 基于红黑树数据结构的实现　　不允许空键空值　　线程不安全</li>
</ul>
</li>
<li>Map - HashTable<ul>
<li>Hashtable:基于散列表的实现　　允许空键空值　　线程安全</li>
</ul>
</li>
<li>Map - WeakHashMap<ul>
<li>改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</li>
</ul>
</li>
<li>Map - LinkedHashMap<ul>
<li>具有HashMap的所有特性。</li>
<li>内部对数据的存储也是数组加链表的形式。</li>
<li><strong>多了一个双向链表来维护内部数据的顺序关系。</strong></li>
</ul>
</li>
<li>SparseArray<ul>
<li>采用了二分法方式存储数据（安卓的一个集合类）</li>
<li>key必须为int类型，这中情况下的HashMap可以用SparseArray代替</li>
<li>避免了HashMap自动装箱得到内存消耗</li>
</ul>
</li>
<li>ArrayMap<ul>
<li><code>ArrayMap</code> 实现了<code>implements Map&lt;K, V&gt;</code>接口，所以它也是一个<strong>关联数组、哈希表</strong>。</li>
<li>存储以<code>key-&gt;value</code> 结构形式的数据。</li>
<li>它也是<strong>线程不安全</strong>的，允许<strong>key为null</strong>,<strong>value为null</strong>。</li>
<li>内部实现是<strong>基于两个数组</strong>。 <ul>
<li>一个<code>int[]</code>数组，用于保存每个item的<code>hashCode</code>. </li>
<li>一个<code>Object[]</code>数组，保存<code>key/value</code>键值对。<strong>容量</strong>是上一个数组的<strong>两倍</strong>。 </li>
</ul>
</li>
<li>使用<strong>二分查找法</strong>得到相应的index</li>
</ul>
</li>
</ul>
<blockquote>
<p>在除需要排序时使用TreeSet,TreeMap外,都应使用HashSet,HashMap,因为他们的效率更高。</p>
</blockquote>
<p>3.1 <code>ArrayList</code>的构造函数有三个</p>
<ol>
<li>无参构造 容量为10</li>
<li>ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表</li>
<li>ArrayList(int initialCapacity) 指定初始容量</li>
</ol>
<p>3.2 <code>Iterator(迭代器)</code>支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException)</p>
<h4 id="4-Java垃圾回收机制"><a href="#4-Java垃圾回收机制" class="headerlink" title="4.Java垃圾回收机制"></a>4.Java垃圾回收机制</h4><p>4.1 调用system.gc() Runtime.getRuntime.gc()</p>
<p>4.2 垃圾回收:释放那些不再持有任何引用的对象的内存</p>
<p>4.3 怎样判断是否需要收集：</p>
<ol>
<li>引用计数法：对象没有任何引用与之关联(无法解决循环引用)</li>
<li>对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。</li>
</ol>
<p>4.4 垃圾回收方法</p>
<ol>
<li>标记清除法(Mark-Sweeping):易产生内存碎片</li>
<li>复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半</li>
<li>标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚</li>
<li>分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.<br>新生代划分：较大的eden区 和 2个survivor区</li>
</ol>
<p>4.5 内存分配</p>
<ul>
<li>新生代 |Eden Space|From Space|To Space|</li>
<li>对象主要分配在新生代的EdenSpace和FromSpace</li>
<li>如果EdenSapce和FromSpace空间不足,则发起一次GC</li>
<li>若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。</li>
<li>新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC</li>
</ul>
<p>其他</p>
<ul>
<li>优先在Eden上分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代</li>
<li>动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代</li>
<li>空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC</li>
</ul>
<h4 id="5-一些重要的关键字"><a href="#5-一些重要的关键字" class="headerlink" title="5.一些重要的关键字"></a>5.一些重要的关键字</h4><ul>
<li><p>volatile<br>Java 语言提供了一种稍弱的同步机制,即<code>volatile</code>变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。<code>volatile</code>修饰变量,<strong>每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存</strong>。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序</p>
</li>
<li><p>final<br><code>final</code>修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。</p>
</li>
</ul>
<h4 id="6-多线程-amp-并发-amp-同步-amp-锁"><a href="#6-多线程-amp-并发-amp-同步-amp-锁" class="headerlink" title="6.多线程 &amp; 并发 &amp; 同步 &amp; 锁"></a>6.多线程 &amp; 并发 &amp; 同步 &amp; 锁</h4><p>6.1 线程的run方法和start方法</p>
<ul>
<li><code>start方法</code><br>用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。</li>
<li><code>run方法</code><br>只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。</li>
</ul>
<p>6.2 ReadWriteLock(读写锁)</p>
<p>写写互斥 读写互斥 读读并发<br>在读多写少的情况下可以提高效率 </p>
<p>6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用</p>
<p>6.4 wait与notify、notifyall一起用</p>
<p>6.5 sleep与wait的异同点</p>
<ol>
<li>sleep是Thread类的静态方法,wait来自object类</li>
<li>sleep不释放锁,wait释放锁</li>
<li>wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用</li>
<li>都可以抛出InterruptedException</li>
</ol>
<p>6.6 让一个线程停止执行</p>
<p>异常 - 停止执行<br>休眠 - 停止执行<br>阻塞 - 停止执行</p>
<p>6.7 ThreadLocal相关</p>
<ul>
<li><p>ThreadLocal解决了变量并发访问的冲突问题</p>
<ul>
<li>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</li>
<li><strong>原理</strong><ul>
<li>这个类之所以能够存储每个thread的信息，是因为它的内部有一个Values内部类，而Values中有一个Object组。</li>
<li>Objec数组是以一种近似于map的形式来存储数据的，其中偶数位存ThreadLocal的弱引用，它的下一位存值。</li>
<li>在寻址的时候，Values采用一种很神奇的方式——斐波拉契散列寻址Values里面的getAfterMiss()方式让人觉得很奇怪</li>
</ul>
</li>
</ul>
</li>
<li><p>与synchronized同步机制的比较</p>
<ul>
<li>首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。<br>而ThreadLocal采用了以“以空间换时间”的方式。</li>
</ul>
</li>
</ul>
<h4 id="7-接口与抽象类"><a href="#7-接口与抽象类" class="headerlink" title="7.接口与抽象类"></a>7.接口与抽象类</h4><ol>
<li>一个子类只能继承一个抽象类,但能实现多个接口</li>
<li>抽象类可以有构造方法,接口没有构造方法</li>
<li>抽象类可以有普通成员变量,接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li>
<li>抽象类可以有静态方法，接口不能有静态方法</li>
<li>抽象类中的方法可以是public、protected和默认;接口方法只有public</li>
</ol>
<h4 id="8-Statement接口"><a href="#8-Statement接口" class="headerlink" title="8.Statement接口"></a>8.Statement接口</h4><p>8.1</p>
<ul>
<li>Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞</li>
<li>PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入</li>
<li>CallableStatement接口扩展PreparedStatement，用来调用存储过程</li>
<li>public interface CallableStatement extends PreparedStatement </li>
<li>public interface PreparedStatement extends Statement </li>
<li>BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类</li>
</ul>
<p>8.2 Statement与PrepareStatement的区别</p>
<ul>
<li><p>创建时的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">PreparedStatement preStatement = conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rSet = statement.executeQuery(sql);</span><br><span class="line">ResultSet pSet = preStatement.executeQuery();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，<br>而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些</p>
<ul>
<li>安全性</li>
</ul>
<p>preStatement是预编译的，所以可以有效的防止SQL注入等问题</p>
<ul>
<li>代码的可读性和可维护性</li>
</ul>
<p>PreparedStatement更胜一筹</p>
<h4 id="9-抽象类和最终类"><a href="#9-抽象类和最终类" class="headerlink" title="9.抽象类和最终类"></a>9.抽象类和最终类</h4><p>抽象类可以没有抽象方法,最终类可以,没有最终方法</p>
<p>最终类不能被继承,最终方法不能被重写(可以重载)</p>
<h4 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h4><p>10.1 throw、throws、try…catch、finally</p>
<ol>
<li>throws用在方法上,方法内部通过throw抛出异常</li>
<li>try用于检测包住的语句块,若有异常,抛出并执行catch子句</li>
<li>catch捕获try块中抛出的异常并处理</li>
</ol>
<p>10.2 关于<code>finally</code></p>
<ol>
<li>finally不管有没有异常都要处理</li>
<li>finally{}比return先执行,多个return执行一个后就不在执行</li>
<li>不管有木有异常抛出,finally在return返回前执行</li>
</ol>
<p>10.3 受检查异常和运行时异常<br><img src="http://uploadfiles.nowcoder.com/images/20151010/214250_1444467985224_6A144C1382BBEF1BE30E9B91BC2973C8" alt=""></p>
<ol>
<li><p>粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 </p>
</li>
<li><p>绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… </p>
</li>
<li><p>而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 </p>
</li>
</ol>
<h4 id="11-this-amp-super"><a href="#11-this-amp-super" class="headerlink" title="11.this &amp; super"></a>11.this &amp; super</h4><p>11.1 super出现在父类的子类中。有三种存在方式</p>
<ol>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ol>
<ul>
<li>super只能指代其直接父类</li>
</ul>
<p>11.2 this() &amp; super()在构造方法中的区别</p>
<ol>
<li>调用super()必须写在子类构造方法的第一行,否则编译不通过</li>
<li>super从子类调用父类构造,this在同一类中调用其他构造</li>
<li>均需要放在第一行</li>
<li>尽管可以用this调用一个构造器,却不能调用2个</li>
<li>this和super不能出现在同一个构造器中,否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ol>
<h4 id="12-修饰符一览"><a href="#12-修饰符一览" class="headerlink" title="12.修饰符一览"></a>12.修饰符一览</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 			类内部  	同一个包		子类 		任何地方</span><br><span class="line">private 		yes</span><br><span class="line">default         yes			yes</span><br><span class="line">protected		yes			yes				yes</span><br><span class="line">public			yes			yes				yes			yes</span><br></pre></td></tr></table></figure>
<h4 id="13-构造内部类对象"><a href="#13-构造内部类对象" class="headerlink" title="13.构造内部类对象"></a>13.构造内部类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Enclosingone</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span> </span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Insideone</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Enclosingone.Insideone obj1 = <span class="keyword">new</span> Enclosingone().new Insideone();</span><br><span class="line">	Enclosingone.Insideone obj2 = <span class="keyword">new</span> Enclosingone.Insideone();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-序列化"><a href="#14-序列化" class="headerlink" title="14.序列化"></a>14.序列化</h4><p>声明为static和transient类型的数据不能被序列化,序列化的笔记参见[Java-note-序列化.md][5]</p>
<h4 id="15-Java的方法区"><a href="#15-Java的方法区" class="headerlink" title="15.Java的方法区"></a>15.Java的方法区</h4><p>与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</p>
<h4 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16.正则表达式"></a>16.正则表达式</h4><p><strong>次数符号</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 0或多次</span><br><span class="line">+ 1或多次</span><br><span class="line">？0或1次</span><br><span class="line">&#123;n&#125; 恰n次</span><br><span class="line">&#123;n,m&#125; 从n到m次</span><br></pre></td></tr></table></figure></p>
<p><strong>其他符号</strong></p>
<p>符号    等价形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d		[0-9]</span><br><span class="line">\D      [^0-9]  </span><br><span class="line">\w 		[a-zA-Z_0-9]</span><br><span class="line">\W 		[^a-zA-Z_0-9]</span><br><span class="line">\s 		[\t\n\r\f]</span><br><span class="line">\S 		[^\t\n\r\f]</span><br><span class="line">. 		任何字符</span><br></pre></td></tr></table></figure></p>
<p><strong>边界匹配器</strong></p>
<p>行开头    ^<br>行结尾  $<br>单词边界 \b</p>
<p><strong>贪婪模式</strong>:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配</p>
<p><strong>环视</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符 				描述 					匹配对象</span><br><span class="line">.					单个任意字符			</span><br><span class="line">[...] 				字符组 					列出的任意字符</span><br><span class="line">[^...] 										未列出的任意字符</span><br><span class="line">^ 					caret 					行的起始位置</span><br><span class="line">$     				dollar 					行的结束位置</span><br><span class="line">\&lt;   										单词的起始位置</span><br><span class="line">\&gt; 											单词的结束位置</span><br><span class="line">\b   				单词边界</span><br><span class="line">\B 					非单词边界</span><br><span class="line">(?=Expression)		顺序肯定环视			成功,如果右边能够匹配</span><br><span class="line">(?!Expression)		顺序否定环视			成功,如果右边不能够匹配</span><br><span class="line">(?&lt;=Expression)		逆序肯定环视			成功,如果左边能够匹配</span><br><span class="line">(?&lt;!Expression) 	逆序否定环视			成功,如果左边不能够匹配</span><br></pre></td></tr></table></figure>
<p>举例:北京市(海定区)(朝阳区)(西城区)</p>
<p>Regex: .*(?=\()</p>
<p><strong>模式和匹配器的典型调用次序</strong></p>
<ol>
<li>把正则表达式编译到模式中<br>Pattern p = Pattern.compile(“a*b”);</li>
<li>创建给定输入与此模式的匹配器<br>Matcher m = p.matcher(“aaab”);</li>
<li>尝试将整个区域与此模式匹配<br>boolean b = m.matches();</li>
</ol>
<h4 id="17-Servlet-amp-JSP-amp-Tomcat"><a href="#17-Servlet-amp-JSP-amp-Tomcat" class="headerlink" title="17.Servlet &amp; JSP &amp; Tomcat"></a>17.Servlet &amp; JSP &amp; Tomcat</h4><p>17.1 Servlet继承实现结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Servlet (接口) 			--&gt;      init|service|destroy方法</span><br><span class="line">GenericServlet(抽象类)  --&gt;      与协议无关的Servlet</span><br><span class="line">HttpServlet(抽象类)		--&gt;		 实现了http协议</span><br><span class="line">自定义Servlet			--&gt;		 重写doGet/doPost</span><br></pre></td></tr></table></figure></p>
<p>17.2 编写Servlet的步骤</p>
<ol>
<li>继承HttpServlet</li>
<li>重写doGet/doPost方法</li>
<li>在web.xml中注册servlet</li>
</ol>
<p>17.3 Servlet生命周期</p>
<ol>
<li><code>init</code>:仅执行一次,负责装载servlet时初始化servlet对象</li>
<li><code>service</code>:核心方法,一般get/post两种方式</li>
<li><code>destroy</code>:停止并卸载servlet,释放资源</li>
</ol>
<p>17.4 过程</p>
<ol>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法</li>
<li>客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service</li>
<li>加载和实例化、初始化、处理请求、服务结束</li>
</ol>
<p>17.5 doPost方法要抛出的异常:ServletExcception、IOException</p>
<p>17.6 Servlet容器装载Servlet</p>
<ol>
<li>web.xml中配置load-on-startup启动时装载</li>
<li>客户首次向Servlet发送请求</li>
<li>Servlet类文件被更新后,重新装载Servlet</li>
</ol>
<p>17.7 HttpServlet容器响应web客户请求流程</p>
<ol>
<li>Web客户向servlet容器发出http请求</li>
<li>servlet容器解析Web客户的http请求</li>
<li>servlet容器创建一个HttpRequest对象,封装http请求信息</li>
<li>servlet容器创建一个HttpResponse对象</li>
<li>servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象</li>
<li>HttpServlet调用httprequest的有关方法,获取http请求信息</li>
<li>httpservlet调用httpresponse的有关方法,生成响应数据</li>
<li>Servlet容器把HttpServlet的响应结果传给web客户</li>
</ol>
<p>17.8 HttpServletRequest完成的功能</p>
<ol>
<li>request.getCookie()</li>
<li>request.getHeader(String s)</li>
<li>request.getContextPath()</li>
</ol>
<p>17.9 HttpServletResponse完成的功能</p>
<ol>
<li>设http头</li>
<li>设置Cookie</li>
<li>输出返回数据</li>
</ol>
<p>17.10 <code>session</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession(boolean create)</span><br><span class="line">返回当前请求的会话</span><br></pre></td></tr></table></figure></p>
<p>17.11 JSP的前身就是Servlet</p>
<p>17.12 Tomcat容器的等级</p>
<p>Tomcat - <strong>Container</strong> - <strong>Engine</strong> - <strong>Host</strong> - <strong>Servlet</strong> - 多个Context(一个Context对应一个web工程)-Wrapper</p>
<p>17.13 Servlet与JSP九大内置对象的关系</p>
<p>JSP对象                 怎样获得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. out				-&gt;		response.getWriter</span><br><span class="line">2. request 		-&gt;		Service方法中的req参数</span><br><span class="line">3. response 		-&gt;		Service方法中的resp参数</span><br><span class="line">4. session 		-&gt;		request.getSession</span><br><span class="line">5. application 	-&gt;		getServletContext</span><br><span class="line">6. exception 		-&gt;		Throwable</span><br><span class="line">7. page  			-&gt;		this</span><br><span class="line">8. pageContext  	-&gt;		PageContext</span><br><span class="line">9. Config 			-&gt;		getServletConfig</span><br></pre></td></tr></table></figure></p>
<p>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。</p>
<h4 id="18-struts"><a href="#18-struts" class="headerlink" title="18.struts"></a>18.struts</h4><ol>
<li>struts可进行文件上传</li>
<li>struts基于MVC模式</li>
<li>struts让流程结构更清晰</li>
<li>struts有许多action类,会增加类文件数目</li>
</ol>
<h4 id="19-Hibernate的7大鼓励措施"><a href="#19-Hibernate的7大鼓励措施" class="headerlink" title="19.Hibernate的7大鼓励措施"></a>19.Hibernate的7大鼓励措施</h4><ol>
<li>尽量使用many-to-one,避免使用单项one-to-many</li>
<li>灵活使用单项one-to-many</li>
<li>不用一对一,使用多对一代替一对一</li>
<li>配置对象缓存,不使用集合对象</li>
<li>一对多使用bag,多对一使用set</li>
<li>继承使用显示多态</li>
<li>消除大表,使用二级缓存</li>
</ol>
<h4 id="20-JVM"><a href="#20-JVM" class="headerlink" title="20.JVM"></a>20.JVM</h4><p>20.1 JVM内存配置参数</p>
<ol>
<li>-Xmx:最大堆大小</li>
<li>-Xms:初始堆大小(最小内存值)</li>
<li>-Xmn:年轻代大小</li>
<li>-XXSurvivorRatio:3 意思是Eden:Survivor=3:2</li>
<li>-Xss栈容量</li>
<li>-XX:+PrintGC 输出GC日志</li>
<li>-XX:+PrintGCDetails 输出GC的详细日志</li>
</ol>
<p>20.2 JVM内存结构</p>
<ol>
<li>堆:Eden、Survivor、old 线程共享</li>
<li>方法区(非堆):持久代,代码缓存,线程共享</li>
<li>JVM栈:中间结果,局部变量,线程隔离</li>
<li>本地栈:本地方法(非Java代码)</li>
<li>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址</li>
<li>注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分)</li>
</ol>
<h4 id="21-面向对象的五大基本原则-solid"><a href="#21-面向对象的五大基本原则-solid" class="headerlink" title="21.面向对象的五大基本原则(solid)"></a>21.面向对象的五大基本原则(solid)</h4><ol>
<li><p>S单一职责<code>SRP</code>:Single-Responsibility Principle<br>一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。</p>
</li>
<li><p>O开放封闭原则<code>OCP</code>:Open-Closed Principle<br>软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭</p>
</li>
<li><p>L里氏替换原则<code>LSP</code>:Liskov-Substitution Principle<br>子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。</p>
</li>
<li><p>I接口隔离原则<code>ISP</code>:Interface-Segregation Principle<br>使用多个小的接口,而不是一个大的总接口</p>
</li>
<li><p>D依赖倒置原则<code>DIP</code>:Dependency-Inversion Principle<br>依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。</p>
</li>
</ol>
<h5 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h5><ol>
<li>封装变化</li>
<li>少用继承 多用组合</li>
<li>针对接口编程 不针对实现编程</li>
<li>为交互对象之间的松耦合设计而努力</li>
<li>类应该对扩展开发 对修改封闭（开闭OCP原则）</li>
<li>依赖抽象，不要依赖于具体类（依赖倒置DIP原则）</li>
<li><p>密友原则：只和朋友交谈（最少知识原则）</p>
<p>说明：将方法调用保持在界限内，只调用属于以下范围的方法：<br>该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象</p>
</li>
<li><p>别找我（调用我） 我会找你（调用你）（好莱坞原则）</p>
</li>
<li>一个类只有一个引起它变化的原因（单一职责SRP原则）</li>
</ol>
<h4 id="22-null可以被强制转型为任意类型的对象。"><a href="#22-null可以被强制转型为任意类型的对象。" class="headerlink" title="22.null可以被强制转型为任意类型的对象。"></a>22.null可以被强制转型为任意类型的对象。</h4><h4 id="23-代码执行次序"><a href="#23-代码执行次序" class="headerlink" title="23.代码执行次序"></a>23.代码执行次序</h4><ol>
<li>多个静态成员变量,静态代码块按顺序执行</li>
<li>单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法</li>
<li>构造块在每一次创建对象时执行</li>
<li>涉及父类和子类的初始化过程<br>a.初始化父类中的静态成员变量和静态代码块<br> b.初始化子类中的静态成员变量和静态代码块<br> c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖)<br> d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法</li>
</ol>
<h4 id="24-红黑树"><a href="#24-红黑树" class="headerlink" title="24.红黑树"></a>24.红黑树</h4><p><strong>二叉搜索树</strong>:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： <strong>若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；</strong>它的左、右子树也分别为二叉搜索树。</p>
<p><strong>红黑树</strong>的定义:满足以下五个性质的二叉搜索树</p>
<ol>
<li>每个结点或是红色的或是黑色的</li>
<li>根结点是黑色的</li>
<li>每个叶结点是黑色的</li>
<li>如果一个结点是红色的,则它的两个子结点是黑色的</li>
<li>对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点</li>
</ol>
<p>黑高</p>
<p>从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。<br>红黑树的黑高为其根结点的黑高。</p>
<p>其他</p>
<ul>
<li>一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1)</li>
<li>结点的属性(五元组):color key left right p</li>
<li>动态集合操作最坏时间复杂度为O(lgn)</li>
</ul>
<h4 id="25-排序"><a href="#25-排序" class="headerlink" title="25.排序"></a>25.排序</h4><ul>
<li><p>稳定排序:插入排序、冒泡排序、归并排序、基数排序</p>
</li>
<li><p>插入排序[稳定]<br>适用于小数组,数组已排好序或接近于排好序速度将会非常快<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>归并排序[稳定]<br>采用分治法<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>冒泡排序[稳定]<br>复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>基数排序 分配+收集[稳定]<br>复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r)</p>
</li>
<li><p>树排序<br>应用：TreeSet的add方法、TreeMap的put方法<br>不支持相同元素,没有稳定性问题<br>复杂度：平均最差O(nlogn)</p>
</li>
<li><p>堆排序(就地排序)<br>复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>快速排序<br>复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]<br>栈空间0(lgn) - O(n)</p>
</li>
<li><p>选择排序<br>复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]</p>
</li>
<li><p>希尔排序<br>复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1)</p>
</li>
</ul>
<h4 id="26-查找与散列"><a href="#26-查找与散列" class="headerlink" title="26.查找与散列"></a>26.查找与散列</h4><p>26.1 散列函数设计</p>
<ul>
<li><p>直接定址法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用</span><br><span class="line"></span><br><span class="line">* 除留余数法:```f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>DJBX33A算法(time33哈希算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">平方取中法 折叠法 更多....</span><br><span class="line"></span><br><span class="line">26.2 冲突处理</span><br><span class="line"></span><br><span class="line">闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中</span><br><span class="line"></span><br><span class="line">- 线性探测:易产生堆积现象(基地址不同堆积在一起)</span><br><span class="line">- 二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2...可以消除基本聚集</span><br><span class="line">- 随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集</span><br><span class="line">- 双散列:避免二次聚集</span><br><span class="line"></span><br><span class="line">开散列(链地址法):原地处理</span><br><span class="line"></span><br><span class="line">- 同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。</span><br><span class="line">- 优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间</span><br><span class="line"></span><br><span class="line">#### 27.枚举类</span><br><span class="line"></span><br><span class="line">JDK1.5出现 每个枚举值都需要调用一次构造函数</span><br><span class="line"></span><br><span class="line">#### 28.数组复制方法</span><br><span class="line"></span><br><span class="line">1. for逐一复制</span><br><span class="line">2. System.arraycopy() -&gt; 效率最高native方法</span><br><span class="line">3. Arrays.arrayOf() -&gt; 本质调用arraycopy</span><br><span class="line">4. clone方法 -&gt; 返回Object[],需要强制类型转换</span><br><span class="line"></span><br><span class="line">#### 29.多态</span><br><span class="line"></span><br><span class="line">1. Java通过方法重写和方法重载实现多态 </span><br><span class="line">2. 方法重写是指子类重写了父类的同名方法 </span><br><span class="line">3. 方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 </span><br><span class="line"></span><br><span class="line">#### 30.Java文件</span><br><span class="line"></span><br><span class="line">.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与</span><br><span class="line">文件名相同。而且这些类和写在多个文件中没有区别。</span><br><span class="line"></span><br><span class="line">#### 31.Java移位运算符</span><br><span class="line"></span><br><span class="line">java中有三种移位运算符</span><br><span class="line"></span><br><span class="line">1. &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0</span><br><span class="line">2. &gt;&gt; :带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1</span><br><span class="line">3. &gt;&gt;&gt; :无符号右移,忽略符号位,空位都以0补齐</span><br><span class="line"></span><br><span class="line">#### 32.形参&amp;实参</span><br><span class="line">1. 形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。</span><br><span class="line">2. 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。</span><br><span class="line">3. 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。</span><br><span class="line"></span><br><span class="line">#### 33.IO</span><br><span class="line">![](http://uploadfiles.nowcoder.com/images/20150328/138512_1427527478646_1.png)</span><br><span class="line"></span><br><span class="line">#### 34.局部变量为什么要初始化</span><br><span class="line"></span><br><span class="line">局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</span><br><span class="line"></span><br><span class="line">#### 35.JDK提供的用于并发编程的同步器</span><br><span class="line"></span><br><span class="line">1. Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</span><br><span class="line">2. CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。</span><br><span class="line">3. 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</span><br><span class="line"></span><br><span class="line">#### 36.Java类加载器</span><br><span class="line"></span><br><span class="line">一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： </span><br><span class="line"></span><br><span class="line">1. Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等</span><br><span class="line">2. Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等</span><br><span class="line">3. App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。 </span><br><span class="line">   classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。 </span><br><span class="line">   所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</span><br><span class="line"></span><br><span class="line">#### 37.Java语言的鲁棒性</span><br><span class="line"></span><br><span class="line">Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</span><br><span class="line"></span><br><span class="line">#### 38.Java语言特性</span><br><span class="line"></span><br><span class="line">1. Java致力于检查程序在编译和运行时的错误</span><br><span class="line">2. Java虚拟机实现了跨平台接口</span><br><span class="line">3. 类型检查帮助检查出许多开发早期出现的错误</span><br><span class="line">4. Java自己操纵内存减少了内存出错的可能性</span><br><span class="line">5. Java还实现了真数组，避免了覆盖数据的可能</span><br><span class="line"></span><br><span class="line">#### 39.Hibernate延迟加载</span><br><span class="line"></span><br><span class="line">1. Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） </span><br><span class="line">2. Hibernate3 提供了属性的延迟加载功能 </span><br><span class="line">   当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 </span><br><span class="line">3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 </span><br><span class="line">4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</span><br><span class="line"></span><br><span class="line">#### 40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。</span><br><span class="line"></span><br><span class="line">#### 41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。</span><br><span class="line"></span><br><span class="line">#### 42.Java语法糖</span><br><span class="line"></span><br><span class="line">1. Java7的switch用字符串 - hashcode方法 switch用于enum枚举</span><br><span class="line">2. 伪泛型 - List&lt; E&gt;原始类型</span><br><span class="line">3. 自动装箱拆箱 - Integer.valueOf和Integer.intValue</span><br><span class="line">4. foreach遍历 - Iterator迭代器实现</span><br><span class="line">5. 条件编译</span><br><span class="line">6. enum枚举类、内部类</span><br><span class="line">7. 可变参数 - 数组</span><br><span class="line">8. 断言语言</span><br><span class="line">9. try语句中定义和关闭资源</span><br><span class="line"></span><br><span class="line">#### 43.JVM工具</span><br><span class="line"></span><br><span class="line">命令行</span><br><span class="line"></span><br><span class="line">1. jps(jvm processor status)虚拟机进程状况工具</span><br><span class="line">2. jstat(jvm statistics monitoring)统计信息监视</span><br><span class="line">3. jinfo(configuration info for java)配置信息工具</span><br><span class="line">4. jmap(memory map for java)Java内存映射工具</span><br><span class="line">5. jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具</span><br><span class="line">6. jstack(Stack Trace for Java)Java堆栈跟踪工具</span><br><span class="line">7. HSDIS：JIT生成代码反汇编</span><br><span class="line"></span><br><span class="line">可视化</span><br><span class="line">1. JConsole(Java Monitoring and Management Console):Java监视与管理控制台</span><br><span class="line">2. VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具       </span><br><span class="line"></span><br><span class="line">#### 44.内部类为什么可以访问外部类的私有属性</span><br><span class="line"></span><br><span class="line">在内部类构造的时候，会将外部类的引用传递进来，并且作为内部类的一个属性，所以内部类会持有一个其外部类的引用。</span><br><span class="line"></span><br><span class="line">当内部类调用外部类的私有属性时，其真正的执行是调用了编译器生成的属性的静态方法（即acess$0,access$1等）来获取这些属性值。这一切都是编译器的特殊处理。</span><br><span class="line"></span><br><span class="line">外部类可以通过内部类的实例获取私有属性x的操作.</span><br><span class="line"></span><br><span class="line">#### 45.如何让内部类私有成员不被外部访问</span><br><span class="line"></span><br><span class="line">使用匿名内部类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class PrivateToOuter &#123;</span><br><span class="line">  Runnable mRunnable = new Runnable()&#123;</span><br><span class="line">      private int x=10;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">      PrivateToOuter p = new PrivateToOuter();</span><br><span class="line">      //System.out.println(&quot;anonymous class private filed= &quot;+ p.mRunnable.x); //not allowed</span><br><span class="line">      p.mRunnable.run(); // allowed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<p>由于mRunnable对象的类型为Runnable，而不是匿名内部类的类型（我们无法正常拿到），而Runanble中没有x这个属性，所以mRunnable.x是不被允许的。</p>
<h4 id="46-Java匿名内部类访问外部变量，为何需被标志为final？"><a href="#46-Java匿名内部类访问外部变量，为何需被标志为final？" class="headerlink" title="46. Java匿名内部类访问外部变量，为何需被标志为final？"></a>46. Java匿名内部类访问外部变量，为何需被标志为final？</h4><ul>
<li>这要从闭包说起，匿名内部类和外部方法形成了一个闭包，因此，匿名内部类能够访问外部方法的变量，看起来是一种“天经地义”的事情，Java语言当然也需要实现这种特性，但是这里遇到了一个问题。</li>
<li>匿名内部类的生命周期可能比外部的类要长，因此访问外部局部变量有可能是访问不到的。</li>
<li>那怎么办呢？Java语言为了实现这种特性， 只好将外部的局部变量偷偷的赋值了一份给匿名内部类。那这样匿名内部类就可以肆无忌惮的访问外部局部变量了。</li>
<li>问题又来了，这种通过赋值的形式有一个缺陷，匿名内部类不可以修改“原来的局部变量”，因为是一份“复制品”，修改复制品对原变量没什么影响啊。</li>
<li>那怎么办？ Java语言干脆强制要求被匿名内部类访问的外部局部变量必须是final的，什么意思呢？就是“一刀切”，不让修改了。</li>
</ul>
<h4 id="47-非静态内部类为什么不能有静态成员"><a href="#47-非静态内部类为什么不能有静态成员" class="headerlink" title="47. 非静态内部类为什么不能有静态成员"></a>47. 非静态内部类为什么不能有静态成员</h4><ul>
<li>static类型的属性和方法，在类加载的时候就会存在于内存中。</li>
<li>要想使用某个类的static属性和方法，那么这个类必须要加载到虚拟机- 中。</li>
<li>非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。</li>
</ul>
<p>在外部类并没有实例化，内部类还没有加载，这时候如果调用内部类的静态成员或方法，内部类还没有加载，却试图在内存中创建该内部类的静态成员，这明显是矛盾的。</p>
<p>所以非静态内部类不能有静态成员变量或静态方法。</p>
<h4 id="48-手写实现二分查找"><a href="#48-手写实现二分查找" class="headerlink" title="48. 手写实现二分查找"></a>48. 手写实现二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;			<span class="comment">//初始中间位置</span></span><br><span class="line">	<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> middle;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/12/10/job2018/" itemprop="url">
                  2018年年底Android悲催的面试之路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-12-10T21:32:46+08:00" content="2018-12-10">
              2018-12-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本人近况"><a href="#本人近况" class="headerlink" title="本人近况"></a>本人近况</h1><p>年底裁人了，一年半没准备面试了，之前换也是内推的，在这个寒冬的冬天还经历此遭，偏偏还赶上裁员<br>心态早已爆炸，大的环境不好，各位且干且珍惜….<br>记录下最近的面试经历，整理下让自己不断进步！</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>我不知道一个人人性究竟可以坏到什么程度，但是我最近亲身经历的确实是这样，我一个安心想做技术的人跟你TMD HR部门的八竿子打不着，又何苦为难我呢？ 之前有个公司的薪酬绩效主管，邵X，只因为我在大会上顶撞了她一个问题，一味着揪着我的把柄不放，甚至特么的为了少给我一个季度的绩效不允许提前转正，真的是坏透了，可能这就是职场，这就是江湖充满尔虞我诈，真的人真是身不由己的，本想与世无争安心踏实做技术，但是某些人却看不得你的安宁。。。还是那句话，出来混的迟早要还的，望好自为之</p>
<h2 id="右划"><a href="#右划" class="headerlink" title="右划"></a>右划</h2><blockquote>
<p>这公司是在拉勾上投的，CEO号称曾于字节跳动，任视频负责人，创建了头条视频APP。公司待遇15薪非常不错，坐落于望京Soho对面的望京融科写字楼</p>
<ul>
<li>面试过程觉得自己挺失败的没有充分准备算法再加上由于一年半没有再面试过了，有点手生，好多应该答上来的问题都没有答好，面试官确实是大牛，没会的问题也稍微讲解了下，不过深度确实蛮深的</li>
<li>印象比较深的几个问题：Lru算法，Binder机制，EventBus实现原理和为什么不能跨进程，Handler如何在handleMessage方法拦截之前发出的message，手写二分法查找（没准备直接跪了），后来让我手写冒泡，我觉得前面已经没戏了（大致说了下双重循环然后赋值也没手写），跨进程几种方式，AIDL，handler机制，ThreadLocal实现原理（回答的很模糊，附上正确答案：每个Thread的对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。</li>
</ul>
</blockquote>
<p>在该类中，最重要的方法就是两个：set()和get()方法。当调用ThreadLocal的get()方法的时候，会先找到当前线程的ThreadLocalMap，然后再找到对应的值。set()方法也是一样。）系统是如何监听ANR的（他说是androidframework层有一个单独的进程），后来问到如何定位和排查我不小心说了blockCanary，他有追问了一下源码和原理我回答的也不是很好（应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。我们通过给主线程的Looper设置一个Printer，打点统计dispatchMessage方法执行的时间，如果超出阀值，表示发生卡顿，则dump出各种信息，提供开发者分析性能瓶颈。）<br>最后知道今天一定挂了，不过还是很有收获的知道自己哪里不足…<br>PS:明天去五道口面试斗鱼，希望能好好把握</p>
<h2 id="斗鱼"><a href="#斗鱼" class="headerlink" title="斗鱼"></a>斗鱼</h2><blockquote>
<p>拉勾投的斗鱼，据说最近在疯狂裁人？只经历了两轮面试，一共面了两个多小时，没到HR，估计歇菜了</p>
<ul>
<li>斗鱼有份笔试题，还是蛮简单的随便写写就ok，一面问的蛮详细的，问的大致是看简历写的东西问的，中规中矩，记忆比较深刻的是问了handlerThread原理,MVP模式（因为斗鱼目前的架构都是mvp），弹幕的实现原理和重叠问题（这个没怎么做过，回答的不是太好，而且之前也是直接用的B站开源的那个库），Kotlin协程（这个没用过,kt的掌握程度还只是入门阶段），Retrofit+Okhttp+Rxjava在华为的好多手机会OOM是由线程数溢出引起如何解决？堆内存，栈内存理解，栈如何转换成堆？内存泄漏是发生在堆内存还是栈内存？为什么？ BlockCanary原理？（第二次被问了！！！看来真要看看源码了）如何实现打印指定阻塞线程的方法名？LinkedHashMap与HashMap区别。。。<br>String a=“A” 与 String a = new String（“A”); 区别，分别存储在哪个区域（这题有误导嫌疑，第一个应该是常量区，堆栈都不是，第二个是栈）MutiDex 第一次ANR以及解决方式（答案参考我简书的文章：<a href="https://www.jianshu.com/p/5a2e33a61ba2" target="_blank" rel="noopener">https://www.jianshu.com/p/5a2e33a61ba2</a> ）<br>我觉得大部分的问题回答的还是不错的，一面问了下薪资然后开始二面</li>
<li>二面印象最深的是根据面向对象设计一个电梯系统，问题的关键点在于所有的属性都跟电梯有关，跟人无关，楼层数是固定的常量…我当时设计跑偏了，总联想到人然后去设计。。<br>结束以后没有HR面，估计歇菜了…再接再厉吧…</li>
</ul>
</blockquote>
<h2 id="Zenjoy"><a href="#Zenjoy" class="headerlink" title="Zenjoy"></a>Zenjoy</h2><blockquote>
<p>这家公司是猎头推荐的，坐落于银河SohoA座，办公环境蛮不错的，产品方向是做海外项目的，不过前后历经将近三个小时的面试着实很令人崩溃，我喝了将近三瓶小瓶怡宝矿泉水才撑到了最后。。。</p>
</blockquote>
<h3 id="一面-amp-二面"><a href="#一面-amp-二面" class="headerlink" title="一面&amp;二面"></a>一面&amp;二面</h3><p>一面，二面问的太多了根本记不住，只记得几个印象深刻的问题，</p>
<ul>
<li>hashcode（）和equals（）的作用、区别、联系？<br>因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：<br>1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br>2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。）</li>
<li>Handler、Looper、MessageQueue、Thread关系？<br>一个线程可以有多个Handler实例，一个线程对应一个Looper，一个Looper也只对应一个MessageQueue，一个MessageQueue对应多个Message和Runnable。所以就形成了一对多的对应关系，一方：线程、Looper、MessageQueue；多方：Handler、Message。同时可以看出另一个一对一关系：一个Message实例对应一个Handler实例。</li>
<li>Service 和 Activity如何交互, 如何在后台下载任务, 并在Activity显示进度？</li>
<li>https握手过程，如何实现数据加密？客户端如何保证安全实现双重证书校验？请你设计一个登录功能，需要注意哪些安全问题?</li>
<li>Hashmap实现原理和如何解决散列碰撞（必问），Hashmap底层为什么是线程不安全的？</li>
<li>HandlerThread原理以及对比单个New Thread的好处，优点以及试用场景？需要注意的是HandlerThread 是单个线程的不太适合执行网络的IO操作，要注意。。</li>
<li>EventBus实现原理</li>
<li>SurfaceView, TextureView区别？<br>从性能和安全性角度出发，使用播放器优先选SurfaceView。<br>1.在android 7.0上系统surfaceview的性能比TextureView更有优势，支持对象的内容位置和包含的应用内容同步更新，平移、缩放不会产生黑边。 在7.0以下系统如果使用场景有动画效果，可以选择性使用TextureView<br>2.SurfaceView优点及缺点优点：可以在一个独立的线程中进行绘制，不会影响主线程，使用双缓冲机制，播放视频时画面更流畅<br>缺点：Surface不在View hierachy中，它的显示也不受View的属性控制，所以不能进行平移，缩放等变换，也不能放在其它ViewGroup中。SurfaceView 不能嵌套使用<br>3.TextureView优点及缺点<br>优点：支持移动、旋转、缩放等动画，支持截图<br>缺点：必须在硬件加速的窗口中使用，占用内存比SurfaceView高，在5.0以前在主线程渲染，5.0以后有单独的渲染线程。</li>
<li>handler postDelay这个延迟是怎么实现的？</li>
<li>Appliction启动过程（App启动过程）？</li>
<li>如何测量应用启动时间？<br>1.可以通过代码打桩，计算启动时间<br>2.命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W [packageName]/[packageName.launchActivity]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>根据之前猎头的情报，三面是没有技术相关的问题的，但是我这个不一样，三面是总监面，首先先手写一个算法，不难，大致意思是：给你一个无序的数组，又给了一个目标值，如果这个数组其中有两个数相加等于这个目标值，请你输出对应两个数的下标？<br>思路也蛮简单的，直接Arrays.sort先排序 按升序来，然后双重循环就可以了。。。写完总监会问下单层for循环时间复杂度—<br>for(int i=1;i &lt;=n;i++) //O(N);<br>for(int j=1;j &lt;=i;j++) //O(N^2);<br>然后是</p>
<ul>
<li>设计模式</li>
<li>Restful接口规范 我俩争论了好半天</li>
<li>观察者模式的原理<br>大概能记得的就是这些，总监可能比较注重基础吧，自认为总体发挥一般可能一面和三面有一些瑕疵，主要二面有一些问题反问面试官也没有给我相应的解释比如那个handler postDelay怎么delay的。。。前前后后面了将近三个小时，最后HR进来让我回去等消息，我知道估计凉凉了。。。</li>
</ul>
<h2 id="莱熙科技"><a href="#莱熙科技" class="headerlink" title="莱熙科技"></a>莱熙科技</h2><blockquote>
<p>这家公司我依稀记得去年年初考虑新机会的时候，那时候还在职，偷偷去面过，真心觉得面试官总是问一些我意想不到的问题，原本是要拒了的，可是Boss直聘上HR小姐姐一再要求要我再来一次，我就安排了今天的第三面（第一面已经拿到offer但是工资与预期差距较大，而且没有太深的技术面再加上公司较小，与我预期的差距也很大就不写了）依稀记得大概一年零八个月前吧，那时候他们还没做海外项目，没想到现在的产品居然是我上家公司的同类竞品项目，他们做的叫LivU，Live Chat，在线视频聊天~于是我决定去试试水。。。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>面试官还是1年零八个月之前的小哥，问题问的果然没有辜负我对他的期望，因为产品做的都是一个路子还有用的框架也是Agora的，答起来轻车熟路，但是有好多让我耳目一新的问题</p>
<ul>
<li>使用GreenDao如何实现创建表、关联表(一对一,一对多,多对多)？</li>
<li>Java调用kotlin 如何不用companion object{}包裹？<br>我解答他之前一直纠结的：在Java中调用kotlin中静态的成员<br>如果一个类中所有的成员都是静态成员，将class改为object就不用每个方法都用companion object{}包裹了。但是小哥说据说是最新kotlin加个注解可以不需要这个包裹？</li>
<li>断点续传实现</li>
<li>代理模式和装饰器模式区别？</li>
<li>java io 装饰器模式。。当时问我用过的哪个包是装饰器模式，我没答上来！</li>
<li>App启动速度优化？</li>
<li>Android 5.0-8.0新特性</li>
<li>Dalvik与ART区别？</li>
<li>进程保活？（伪命题）没有真正意义的进程保活，都是白明单才OK</li>
<li>Retrofit CreateApi实现原理</li>
</ul>
</blockquote>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>二面主要是总监面试，穿插了一些技术，不过总是暗示我来了需要加班啥的要我考虑清楚（我当然想你钱到位，啥都不是事）不过既然这么说了，因为我问了一些公司流程方面的事，他回答是产品快速迭代，本身需求不可能流程化，只能产品做出来去试水，然后再推翻，如此往复计划跟不上变化快，大致我想要的工作方式并不是这样，可能有点分歧，也可能由于本来之前本来三面三个小时心态崩溃，可能态度没有顺着他来，So二面失败，HR小姐姐招人的佣金也没了。。<br>PS:其实内心还是蛮想去的，不过由于之前可能这种工作流程不太适合我，我刚跳出坑，他可能看到了我的犹豫和顾虑吧，所以技术过了也把我Pass了。。不过佛系的我已经无所谓了。。</p>
<h2 id="站酷（ZCOOL）"><a href="#站酷（ZCOOL）" class="headerlink" title="站酷（ZCOOL）"></a>站酷（ZCOOL）</h2><blockquote>
<p>这家公司是拉勾投的，面试官貌似是帮别的部门招聘，应该是做一个在线教育的项目，听名字貌似叫“高高手”？遇到答的不好的题面试官都给予了细致的讲解，我觉得收获蛮大。</p>
</blockquote>
<p>具体的问题大概都有：</p>
<ul>
<li>Retrofit 如何实现文件（或图片上传）接口是如何定义的<br>大意要回答multipart/form-data 文件上传表单中<br>它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</li>
<li>自定义View的属性引用attr，styleable里定义的名称可否与系统已经存在的name重复？当然是不可以的，编译器会预先检查系统已经存在或者之前已经定义重复的</li>
<li>自定义View OnMeasure方法的三种Mode<br>UNSPECIFIED(未指定),父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。<br>EXACTLY(完全)，父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，跟上面的场景1跟2比较相似，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数来确定的。一般这种情况下size&gt;0,有个确定值。<br>AT_MOST(至多)，父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，跟上面场景3比较相似。这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数来确定的，一般是子View的布局参数采用wrap_content的时候。</li>
<li>WebView拦截Url和cookie相关？网页需要设置登录状态等情形</li>
<li>Android中为什么主线程不会因为Looper.loop()里的死循环卡死？<br>Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</li>
<li>解决Android多线程访问SQLite数据库死锁问题？database is locked<br>解决的办法就是保持sqlite连接单例，保持单个SqliteOpenHelper实例，同时对所有数据库操作的方法添加synchronized关键字。也就是说是读写数据库时存在的同步问题，所以采用单例+同步锁的方法，并且在每次数据库操作后都关闭数据库</li>
<li>Android多进程解决单个进程内存分配？<br>微信貌似也用了拆分多进程去降低单个进程的heapSize</li>
<li>Android如何实现大图加载？</li>
<li>WeakReference使用场景？</li>
<li>在Service里实现下载如何刷新UI？</li>
<li>Handler postDelay如何实现不阻塞UI线程？<br>1.postDelay()一个1秒钟的MyTask任务、消息进队，MessageQueue开始阻塞，Looper阻塞，mBlocked为true，在enqueueMessage的if中将needWake = mBlocked。<br>2.然后post一个新的任务、消息进队，判断现在A时间还没到、正在阻塞，把新的任务插入消息队列的头部（MyTask任务的前面），然后此时needWake为true调用nativeWake()方法唤醒线程。<br>3.MessageQueue.next()方法被唤醒后，重新开始读取消息链表，第一个消息B无延时，直接返回给Looper；<br>4.Looper处理完这个消息再次调用next()方法，MessageQueue继续读取消息链表，第二个消息A还没到时间，计算一下剩余时间（假如还剩9秒）继续阻塞；<br>5.直到阻塞时间到或者下一次有Message进队；</li>
</ul>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>这次面试还算是比较全面的面试吧，无论是深度和广度问的都很深，面试之后收获了自己的不足，感觉自己表现还可以，可能由于这个岗位是刚开始招的，时间周期会很长不知道会不会给offer… 不过有收获就是好的~</p>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/10/CommonUtils/" itemprop="url">
                  Android工具类常用的几种方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-10T20:17:30+08:00" content="2017-10-10">
              2017-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-安装应用APK"><a href="#1-安装应用APK" class="headerlink" title="1.安装应用APK"></a>1.安装应用APK</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> private void installApk(String apkFilePath) &#123;</span><br><span class="line">        File apkfile = new File(apkFilePath);        </span><br><span class="line">        <span class="keyword">if</span> (!apkfile.exists()) &#123;            </span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Intent i = new Intent(Intent.ACTION_VIEW);</span><br><span class="line">        i.setDataAndType(Uri.parse(<span class="string">"file://"</span> + apkfile.toString()), <span class="string">"application/vnd.android.package-archive"</span>);</span><br><span class="line">        startActivity(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-MD5算法"><a href="#2-MD5算法" class="headerlink" title="2. MD5算法"></a>2. MD5算法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final static String MD5(String s) &#123;        </span><br><span class="line">            char hexDigits[] = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>&#125;;        </span><br><span class="line">            try &#123;            </span><br><span class="line">            byte[] btInput = s.getBytes();          // 获得MD5摘要算法的 MessageDigest 对象</span><br><span class="line">            MessageDigest mdInst = MessageDigest.getInstance(<span class="string">"MD5"</span>);  // 使用指定的字节更新摘要</span><br><span class="line">            mdInst.update(btInput);                 // 获得密文</span><br><span class="line">            byte[] md = mdInst.digest();            // 把密文转换成十六进制的字符串形式</span><br><span class="line">            int j = md.length;            </span><br><span class="line">            char str[] = new char[j * 2];            </span><br><span class="line">            int k = 0;            //把字节转换成对应的字符串</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; j; i++) &#123;                </span><br><span class="line">                byte byte0 = md[i];</span><br><span class="line">                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];</span><br><span class="line">                str[k++] = hexDigits[byte0 &amp; 0xf];</span><br><span class="line">            &#125;           </span><br><span class="line">                 <span class="built_in">return</span> new String(str);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();            </span><br><span class="line">                 <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-判断现在是否有网络"><a href="#3-判断现在是否有网络" class="headerlink" title="3. 判断现在是否有网络"></a>3. 判断现在是否有网络</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private boolean <span class="function"><span class="title">NetWorkStatus</span></span>() &#123;</span><br><span class="line">        ConnectivityManager cwjManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">        cwjManager.getActiveNetworkInfo();        </span><br><span class="line">        boolean netSataus = <span class="literal">true</span>;        </span><br><span class="line">        <span class="keyword">if</span> (cwjManager.getActiveNetworkInfo() != null) &#123;</span><br><span class="line"></span><br><span class="line">        netSataus = cwjManager.getActiveNetworkInfo().isAvailable();</span><br><span class="line"></span><br><span class="line">        Toast.makeText(this, <span class="string">"网络已经打开"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Builder b = new AlertDialog.Builder(this).setTitle(<span class="string">"没有可用的网络"</span>)</span><br><span class="line">                                        .setMessage(<span class="string">"是否对网络进行设置？"</span>);</span><br><span class="line">        b.setPositiveButton(<span class="string">"是"</span>, new DialogInterface.OnClickListener() </span><br><span class="line">        &#123;    </span><br><span class="line">                public void onClick(DialogInterface dialog, int whichButton) &#123;</span><br><span class="line">                Intent mIntent = new Intent(<span class="string">"/"</span>);</span><br><span class="line">                ComponentName comp = new ComponentName( <span class="string">"com.android.settings"</span>, <span class="string">"com.android.settings.WirelessSettings"</span>);</span><br><span class="line">                mIntent.setComponent(comp);</span><br><span class="line">                mIntent.setAction(<span class="string">"android.intent.action.VIEW"</span>);</span><br><span class="line">                startActivityForResult(mIntent,0); </span><br><span class="line">                &#125;</span><br><span class="line">                &#125;).setNeutralButton(<span class="string">"否"</span>, new DialogInterface.<span class="function"><span class="title">OnClickListener</span></span>() &#123;                        </span><br><span class="line">                public void onClick(DialogInterface dialog, int whichButton) &#123;</span><br><span class="line">                        dialog.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;).show();</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="built_in">return</span> netSataus;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-获取设备屏幕的宽度高度密度"><a href="#4-获取设备屏幕的宽度高度密度" class="headerlink" title="4. 获取设备屏幕的宽度高度密度"></a>4. 获取设备屏幕的宽度高度密度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public  class   DisplayUtil &#123; </span><br><span class="line">     /**</span><br><span class="line">     * 得到设备屏幕的宽度</span><br><span class="line">     */</span><br><span class="line">    public static int getScreenWidth(Context context) &#123;        </span><br><span class="line">        <span class="built_in">return</span> context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">    &#125;    /**</span><br><span class="line">     * 得到设备屏幕的高度</span><br><span class="line">     */</span><br><span class="line">    public static int getScreenHeight(Context context) &#123;        </span><br><span class="line">        <span class="built_in">return</span> context.getResources().getDisplayMetrics().heightPixels;</span><br><span class="line">    &#125;    /**</span><br><span class="line">     * 得到设备的密度</span><br><span class="line">     */</span><br><span class="line">    public static <span class="built_in">float</span> getScreenDensity(Context context) &#123;        </span><br><span class="line">        <span class="built_in">return</span> context.getResources().getDisplayMetrics().density;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-dp、sp-转换为-px-的工具类"><a href="#5-dp、sp-转换为-px-的工具类" class="headerlink" title="5. dp、sp 转换为 px 的工具类"></a>5. dp、sp 转换为 px 的工具类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public  class  DisplayUtil &#123;          </span><br><span class="line">    /**</span><br><span class="line">     * 将px值转换为dip或dp值，保证尺寸大小不变</span><br><span class="line">     */</span><br><span class="line">    public static int px2dip(Context context, <span class="built_in">float</span> pxValue) &#123;        </span><br><span class="line">		final <span class="built_in">float</span> scale = context.getResources().getDisplayMetrics().density;        </span><br><span class="line">		<span class="built_in">return</span> (int) (pxValue / scale + 0.5f);</span><br><span class="line">    &#125;    /**</span><br><span class="line">     * 将dip或dp值转换为px值，保证尺寸大小不变</span><br><span class="line">     * </span><br><span class="line">     * @param dipValue</span><br><span class="line">     * @param scale</span><br><span class="line">     *            （DisplayMetrics类中属性density）</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static int dip2px(Context context, <span class="built_in">float</span> dipValue) &#123;        </span><br><span class="line">        final <span class="built_in">float</span> scale = context.getResources().getDisplayMetrics().density;        </span><br><span class="line">        <span class="built_in">return</span> (int) (dipValue * scale + 0.5f);</span><br><span class="line">    &#125;    /**</span><br><span class="line">     * 将px值转换为sp值，保证文字大小不变</span><br><span class="line">     * </span><br><span class="line">     * @param pxValue</span><br><span class="line">     * @param fontScale</span><br><span class="line">     *            （DisplayMetrics类中属性scaledDensity）</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static int px2sp(Context context, <span class="built_in">float</span> pxValue) &#123;        </span><br><span class="line">        final <span class="built_in">float</span> fontScale = context.getResources().getDisplayMetrics().scaledDensity;        </span><br><span class="line">        <span class="built_in">return</span> (int) (pxValue / fontScale + 0.5f);</span><br><span class="line">    &#125;    /**</span><br><span class="line">     * 将sp值转换为px值，保证文字大小不变</span><br><span class="line">     * </span><br><span class="line">     * @param spValue</span><br><span class="line">     * @param fontScale</span><br><span class="line">     *            （DisplayMetrics类中属性scaledDensity）</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static int sp2px(Context context, <span class="built_in">float</span> spValue) &#123;        </span><br><span class="line">        final <span class="built_in">float</span> fontScale = context.getResources().getDisplayMetrics().scaledDensity;        </span><br><span class="line">        <span class="built_in">return</span> (int) (spValue * fontScale + 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-drawable转bitmap的工具类"><a href="#6-drawable转bitmap的工具类" class="headerlink" title="6.drawable转bitmap的工具类"></a>6.drawable转bitmap的工具类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * drawable转bitmap</span><br><span class="line"> *</span><br><span class="line"> * @param drawable</span><br><span class="line"> * @<span class="built_in">return</span></span><br><span class="line">*/</span><br><span class="line">private Bitmap drawableToBitamp(Drawable drawable) &#123;    </span><br><span class="line">       <span class="keyword">if</span> (null == drawable) &#123;        </span><br><span class="line">       <span class="built_in">return</span> null;</span><br><span class="line">       &#125;<span class="keyword">if</span> (drawable instanceof BitmapDrawable) &#123;</span><br><span class="line">       BitmapDrawable bd = (BitmapDrawable) drawable;        </span><br><span class="line">       <span class="built_in">return</span> bd.getBitmap();</span><br><span class="line">   &#125;    </span><br><span class="line">       int w = drawable.getIntrinsicWidth();    </span><br><span class="line">       int h = drawable.getIntrinsicHeight();</span><br><span class="line">       Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);</span><br><span class="line">       Canvas canvas = new Canvas(bitmap);</span><br><span class="line">       drawable.setBounds(0, 0, w, h);</span><br><span class="line">       drawable.draw(canvas);    </span><br><span class="line">       <span class="built_in">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-文章发布模仿朋友圈时间显示"><a href="#7-文章发布模仿朋友圈时间显示" class="headerlink" title="7.文章发布模仿朋友圈时间显示"></a>7.文章发布模仿朋友圈时间显示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">public static String ChangeTime(Date time) &#123;</span><br><span class="line">        String ftime = <span class="string">""</span>;</span><br><span class="line">        Calendar cal = Calendar.getInstance();        // 判断是否是同一天</span><br><span class="line">        String curDate = dateFormater2.get().format(cal.getTime());</span><br><span class="line">        String paramDate = dateFormater2.get().format(time);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curDate.equals(paramDate)) &#123;            </span><br><span class="line"></span><br><span class="line">    int hour = (int) ((cal.getTimeInMillis() - time.getTime()) / 3600000);            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hour == 0)</span><br><span class="line">                ftime = Math.max(</span><br><span class="line">                        (cal.getTimeInMillis() - time.getTime()) / 60000, 1)</span><br><span class="line">                        + <span class="string">"分钟前"</span>;            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ftime = hour + <span class="string">"小时前"</span>;            </span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> ftime;</span><br><span class="line">        &#125;        long lt = time.getTime() / 86400000;        </span><br><span class="line"></span><br><span class="line">            long ct = cal.getTimeInMillis() / 86400000;        </span><br><span class="line"></span><br><span class="line">            int days = (int) (ct - lt);        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (days == 0) &#123;            </span><br><span class="line"></span><br><span class="line">            int hour = (int) ((cal.getTimeInMillis() - time.getTime()) / 3600000);            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hour == 0)</span><br><span class="line">            ftime = Math.max( (cal.getTimeInMillis() - time.getTime()) / 60000, 1)</span><br><span class="line">                        + <span class="string">"分钟前"</span>;           </span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                ftime = hour + <span class="string">"小时前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days == 1) &#123;</span><br><span class="line">            ftime = <span class="string">"昨天"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days == 2) &#123;</span><br><span class="line">            ftime = <span class="string">"前天 "</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 2 &amp;&amp; days &lt; 31) &#123;</span><br><span class="line">            ftime = days + <span class="string">"天前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt;= 31 &amp;&amp; days &lt;= 2 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"一个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 2 * 31 &amp;&amp; days &lt;= 3 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"2个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 3 * 31 &amp;&amp; days &lt;= 4 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"3个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ftime = dateFormater2.get().format(time);</span><br><span class="line">        &#125;        <span class="built_in">return</span> ftime;</span><br><span class="line">    &#125;    public static String friendly_time(String sdate) &#123;</span><br><span class="line">        Date time = null;        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TimeZoneUtil.isInEasternEightZones())</span><br><span class="line">            time = toDate(sdate);        <span class="keyword">else</span></span><br><span class="line">            time = TimeZoneUtil.transformTime(toDate(sdate),</span><br><span class="line">                    TimeZone.getTimeZone(<span class="string">"GMT+08"</span>), TimeZone.getDefault());        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (time == null) &#123;            </span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ftime = <span class="string">""</span>;</span><br><span class="line">        Calendar cal = Calendar.getInstance();        // 判断是否是同一天</span><br><span class="line">        String curDate = dateFormater2.get().format(cal.getTime());</span><br><span class="line">        String paramDate = dateFormater2.get().format(time);        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curDate.equals(paramDate)) &#123;            </span><br><span class="line"></span><br><span class="line">            int hour = (int) ((cal.getTimeInMillis() - time.getTime()) / 3600000);            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hour == 0)</span><br><span class="line">                ftime = Math.max(</span><br><span class="line">                        (cal.getTimeInMillis() - time.getTime()) / 60000, 1)</span><br><span class="line">                        + <span class="string">"分钟前"</span>;           </span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                ftime = hour + <span class="string">"小时前"</span>;            </span><br><span class="line"></span><br><span class="line">             <span class="built_in">return</span> ftime;</span><br><span class="line">        &#125;        long lt = time.getTime() / 86400000;        </span><br><span class="line"></span><br><span class="line">             long ct = cal.getTimeInMillis() / 86400000;        </span><br><span class="line"></span><br><span class="line">             int days = (int) (ct - lt);        </span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (days == 0) &#123;            </span><br><span class="line"></span><br><span class="line">             int hour = (int) ((cal.getTimeInMillis() - time.getTime()) / 3600000);            </span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (hour == 0)</span><br><span class="line">                ftime = Math.max(</span><br><span class="line">                        (cal.getTimeInMillis() - time.getTime()) / 60000, 1)</span><br><span class="line">                        + <span class="string">"分钟前"</span>;           </span><br><span class="line"></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                ftime = hour + <span class="string">"小时前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days == 1) &#123;</span><br><span class="line">            ftime = <span class="string">"昨天"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days == 2) &#123;</span><br><span class="line">            ftime = <span class="string">"前天 "</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 2 &amp;&amp; days &lt; 31) &#123;</span><br><span class="line">            ftime = days + <span class="string">"天前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt;= 31 &amp;&amp; days &lt;= 2 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"一个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 2 * 31 &amp;&amp; days &lt;= 3 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"2个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (days &gt; 3 * 31 &amp;&amp; days &lt;= 4 * 31) &#123;</span><br><span class="line">            ftime = <span class="string">"3个月前"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ftime = dateFormater2.get().format(time);</span><br><span class="line">        &#125;        <span class="built_in">return</span> ftime;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-时间格式转换工具类"><a href="#8-时间格式转换工具类" class="headerlink" title="8.时间格式转换工具类"></a>8.时间格式转换工具类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static String ConverToString(Date date) &#123;</span><br><span class="line">        DateFormat df = new SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);        </span><br><span class="line">        <span class="built_in">return</span> df.format(date);</span><br><span class="line">    &#125;    </span><br><span class="line">        public static String ConverToString2(Date date)&#123;</span><br><span class="line">        DateFormat df = new SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);        </span><br><span class="line">        <span class="built_in">return</span> df.format(date);</span><br><span class="line">    &#125;    </span><br><span class="line">        public static String ConverToString3(Date date)&#123;</span><br><span class="line">        DateFormat df = new SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);        </span><br><span class="line">        <span class="built_in">return</span> df.format(date);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-验证码倒计时工具类"><a href="#9-验证码倒计时工具类" class="headerlink" title="9.验证码倒计时工具类"></a>9.验证码倒计时工具类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	public class TimeCount extends CountDownTimer &#123;    </span><br><span class="line">    private Button button;    /**</span><br><span class="line">     * 到计时</span><br><span class="line">     * @param millisInFuture  到计时多久,毫秒</span><br><span class="line">     * @param countDownInterval 周期</span><br><span class="line">     * @param button   按钮</span><br><span class="line">     */</span><br><span class="line">    public TimeCount(long millisInFuture, long countDownInterval,Button button) &#123;        </span><br><span class="line">    super(millisInFuture, countDownInterval);        </span><br><span class="line">    this.button =button;</span><br><span class="line">    &#125;    </span><br><span class="line">    public TimeCount(long millisInFuture, long countDownInterval) &#123;        </span><br><span class="line">    super(millisInFuture, countDownInterval);</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">onFinish</span></span>() &#123;// 计时完毕</span><br><span class="line">        button.setText(<span class="string">"获取验证码"</span>);</span><br><span class="line">        button.setClickable(<span class="literal">true</span>);</span><br><span class="line">        button.setBackground(MyApplication.getContext().getResources().getDrawable(R.drawable.radius14));</span><br><span class="line">    &#125;   </span><br><span class="line">     @Override</span><br><span class="line">    public void onTick(long millisUntilFinished) &#123;// 计时过程</span><br><span class="line">        button.setClickable(<span class="literal">false</span>);//防止重复点击</span><br><span class="line">        button.setText(millisUntilFinished / 1000 + <span class="string">"s后重试"</span>);</span><br><span class="line">        button.setBackground(MyApplication.getContext().getResources().getDrawable(R.drawable.radius_gray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-屏幕截图工具类"><a href="#10-屏幕截图工具类" class="headerlink" title="10.屏幕截图工具类"></a>10.屏幕截图工具类</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	public class ScreenShot &#123;</span><br><span class="line">	    </span><br><span class="line">	public static void shoot(Activity a, File filePath) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (filePath == null) &#123;            </span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    <span class="keyword">if</span> (!filePath.getParentFile().exists()) &#123;</span><br><span class="line">            filePath.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = null;        </span><br><span class="line">    try &#123;</span><br><span class="line">            fos = new FileOutputStream(filePath);            </span><br><span class="line">    <span class="keyword">if</span> (null != fos) &#123;</span><br><span class="line">                takeScreenShot(a).compress(Bitmap.CompressFormat.PNG, 100, fos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;            </span><br><span class="line">    <span class="keyword">if</span> (fos != null) &#123;                </span><br><span class="line">    try &#123;</span><br><span class="line">                    fos.flush();</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private static Bitmap takeScreenShot(Activity activity) &#123;</span><br><span class="line">        View view = activity.getWindow().getDecorView();</span><br><span class="line">        view.setDrawingCacheEnabled(<span class="literal">true</span>);</span><br><span class="line">        view.buildDrawingCache();</span><br><span class="line">        Bitmap bitmap = view.getDrawingCache();</span><br><span class="line">        Rect frame = new Rect();</span><br><span class="line">        activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);        </span><br><span class="line">        int statusBarHeight = frame.top;        </span><br><span class="line">        int width = activity.getWindowManager().getDefaultDisplay().getWidth();        </span><br><span class="line">        int height = activity.getWindowManager().getDefaultDisplay()</span><br><span class="line">                .getHeight();        //去掉标题栏</span><br><span class="line">        Bitmap b = Bitmap.createBitmap(bitmap, 0, statusBarHeight, width,</span><br><span class="line">                height - statusBarHeight);</span><br><span class="line">        view.destroyDrawingCache();        </span><br><span class="line">        <span class="built_in">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/06/job/" itemprop="url">
                  2017年Android曲折的求职之路
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-06-06T18:12:35+08:00" content="2017-06-06">
              2017-06-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本人近况"><a href="#本人近况" class="headerlink" title="本人近况"></a>本人近况</h1><p>先说下博主最近近况，5月底毅然离职没想到目前市场这么萧条，怪自己太作，有好的机会不好好把握，非得出来受虐哈，人都是犯贱的……所以目前整理几家去过的公司以免以后被坑。</p>
<h2 id="金开门（好贷网旗下孵化创业公司）"><a href="#金开门（好贷网旗下孵化创业公司）" class="headerlink" title="金开门（好贷网旗下孵化创业公司）"></a>金开门（好贷网旗下孵化创业公司）</h2><blockquote>
<p>这公司是在BOSS直聘上投的<br>总体面试还算不错吧Android技术那面一般也不会问特别深主要是最新的主流技术一般会问下，还有就是之前的项目会大致问一下<br>接下来是总监面，总监是个蛮不错的人，满有亲和力的，大概就是聊推送这一块的，还有支付，因为这公司主要业务是聚合支付相关的，总体还OK<br>接着是HR 谈薪水还有介绍公司近况，貌似最近一直是995的节奏<br>最后是大Boss面貌似很屌的说了一句目前我们就是996的节奏（应该是试探我的），我觉得跟他也没啥好谈，他一幅咄咄逼人的气势，由于他比较强势，我又不妥协，所以就没有后续了…</p>
</blockquote>
<h2 id="音悦台"><a href="#音悦台" class="headerlink" title="音悦台"></a>音悦台</h2><blockquote>
<p>这个也是在Boss直聘上约的，公司就在三里屯SOHO<br>公司主要业务主打MV的剩下的我就不多说了，前几年业务还是挺火的</p>
<p>HR人还是很不错的，公司的环境神马的都没得说，妹子也多╮(╯_╰)╭没给offer确实感觉挺遗憾的</p>
<p>首先光技术面问的就蛮深入的，基本最近貌似招人都比较苛刻~多线程，线程池，handler，Looper源码层，activity源码，四种启动模式，生命周期，View的绘制流程，自定义view，手势传递问的最复杂也最多<br>还有一些开源项目相关的问题吧 okhttp，glide，eventbus相关的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是特么的这个面完之后就没有然后了，估计是薪资没谈拢？</span><br><span class="line">只说按公司流程来说还要有次复试，</span><br><span class="line">HR说下周一大概会通知结果，也确实通知了（比较少有的有职业素质的公司吧）</span><br></pre></td></tr></table></figure>
<h2 id="1905电影网"><a href="#1905电影网" class="headerlink" title="1905电影网"></a>1905电影网</h2><blockquote>
<p>这个是在拉勾上投的，公司在西直门<br>我敢说这个面试官是这么多年我遇到的最能装逼一个，当然人家技术也蛮不错的，你不会的，遇到问题的，人家也耐心给你讲解哟，无形装逼，最为致命啊！如果你技术不是很好的话千万不要去这家公司找虐</p>
<p>博主之前有个朋友也来过这家面试，貌似最后给说开不了他的工资，还跟他说来面试很多<br>给我种感觉 就是面试造核弹，工作拧螺丝？最后还问了我项目里有啥亮点<br>问题蛮多的好多都忘了，大致记住几个</p>
</blockquote>
<p>Glide ，Picasso都分别有几个线程池<br>Asynctask 源码，为什么android4.0以后是串行</p>
<p>OnMeasure 方法几个参数对应含义（这个题问的最多的所以我把答案贴上O(∩_∩)O~</p>
<p>首先我们要理解的是widthMeasureSpec, heightMeasureSpec这两个参数是从哪里来的？onMeasure()函数由包含这个View的具体的ViewGroup调用，因此值也是从这个ViewGroup中传入的。这里我直接给出答案：子类View的这两个参数，由ViewGroup中的layout_width，layout_height和padding以及View自身的layout_margin共同决定。权值weight也是尤其需要考虑的因素，有它的存在情况可能会稍微复杂点。<br>了解了这两个参数的来源，还要知道这两个值的作用。我们只取heightMeasureSpec作说明。这个值由高32位和低16位组成，高32位保存的值叫specMode，可以通过如代码中所示的MeasureSpec.getMode()获取；低16位为specSize，同样可以由MeasureSpec.getSize()获取。那么specMode和specSize的作用有是什么呢？要想知道这一点，我们需要知道代码中的最后一行，所有的View的onMeasure()的最后一行都会调用setMeasureDimension()函数的作用——这个函数调用中传进去的值是View最终的视图大小。也就是说onMeasure()中之前所作的所有工作都是为了最后这一句话服务的。</p>
<p>我们知道在ViewGroup中，给View分配的空间大小并不是确定的，有可能随着具体的变化而变化，而这个变化的条件就是传到specMode中决定的，specMode一共有三种可能：</p>
<p>MeasureSpec.EXACTLY：父视图希望子视图的大小应该是specSize中指定的。</p>
<p>MeasureSpec.AT_MOST：子视图的大小最多是specSize中指定的值，也就是说不建议子视图的大小超过specSize中给定的值。</p>
<p>MeasureSpec.UNSPECIFIED：我们可以随意指定视图的大小。)</p>
<p>广播怎么不跨进程<br>Rxjava 操作符<br>Rxjava 1 2的区别<br>还有问了轮播怎么让用户按下三秒之后继续翻页<br>还有五种进程级别<br>多线程下载，3个线程如何下载10M的文件<br>两列Recyclerview 如果是表格布局怎么添加header view<br>Thread 和intent service </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最牛B的一个问题是类似天猫这种大厂APP实现的全局应用代理是怎么实现的</span><br><span class="line">（本意就是类似于推送的时候处理推送的逻辑不写一大堆switch case，而是在入口处动态去配置就可以）</span><br></pre></td></tr></table></figure>
<h2 id="凡普金科（普惠金融旗下）"><a href="#凡普金科（普惠金融旗下）" class="headerlink" title="凡普金科（普惠金融旗下）"></a>凡普金科（普惠金融旗下）</h2><blockquote>
<p>这个是在拉勾上投的，公司在银河SOHO<br>当时面试地点其实是发的有问题的，前台大门明明在A座嘛，你非得发个D座那边的位置，结果那边的门锁了，我敲了半天才有人开，我才知道走错门了应该从A座的电梯上来，可是就是发的D座，这里吐槽下。。。然后前台妹子给我的笔试题居然是Java的（貌似给错了）</p>
<p>面试的深度基本跟1905那哥们差不多，也是activity启动模式跟手势传递还有Looper的源码那块问的比较多只是这个人最后问了一个尺子的效果：附上项目地址哈<br><a href="https://github.com/kailaisi/WheelSelect" target="_blank" rel="noopener">https://github.com/kailaisi/WheelSelect</a><br>类似这个地址demo的实现效果只是年龄换成了金额（毕竟是做金融的公司 当然这样咯）</p>
<p>只说还有复试，但是也是没下文了 ~~o(&gt;_&lt;)o ~~</p>
</blockquote>
<h2 id="映社（木蚂蚁）"><a href="#映社（木蚂蚁）" class="headerlink" title="映社（木蚂蚁）"></a>映社（木蚂蚁）</h2><blockquote>
<p>这个公司绝对是坑比中的战斗机，去了就让你一直等啊等，等到花都谢了的那种<br>PS：他们现在的项目主要是做直播的产品叫“映社”（有种抄袭映客的嫌疑~~）<br>去的时候公司前台都没人，打电话也没人接，后来一个快递小哥进门了我和另外的一个也是面试的才进去</p>
<p>首先是有笔试题的话说蛮弱智的（做完感觉也不会怎么看，完全就是浪费时间啊啊）然后那哥们把你领到一个类似小会议室的屋子里，这哥们给人的感觉技术也很一般，没有之前面的那么强势，基本都是照着简历问的，问直播跟FFmpeg那块偏多，贝塞尔曲线？自定义View，偶尔穿插下retrofit，Rxjava，热修复神马的，面完之后就出去了让你一直等啊等，等了快40分钟的时候进来说总监在开会<br>这个公司真特么的是个奇葩，你约人的时候不会挑个没会的时间么，貌似拉勾上有个面php的哥们跟我一样也是被搁置一直等啊等，真是日了狗了！最后来了一句改天复试吧</p>
<p>只说还有复试，让我来我也不会来了。。。</p>
</blockquote>
<h2 id="Melons-北京知行远科技"><a href="#Melons-北京知行远科技" class="headerlink" title="Melons(北京知行远科技)"></a>Melons(北京知行远科技)</h2><blockquote>
<p>这家公司是我在拉勾上投的，公司成立于2016年太初创了（我能怎么办，我也很绝望啊，貌似最近拉勾的公司比较少，稀里糊涂就投了╮(╯▽╰)╭）<br>Boss也是做android的，而且还是前最美应用的联合创始人，技术出身还是蛮不错的公司早10晚8做海外项目</p>
<p>但是目前的状况是跟别人挤在一间办公室里，那个隔壁组的貌似是Google天气的团队。。。</p>
<p>技术面还是跟之前的那几家差不多，基本都不会看你做过的项目就咔咔的问底层源码咯，唯一不同的是启动模式那块多问了taskAffinity这个属性，我确实是没用过，面试官拿着macbook一个一个的循序渐进的问着，面试流程大概一个半小时左右，然后跟boss聊了聊薪资和之前为什么离职，因为是早上十点半约的，一直聊到了中午12点40多</p>
<p>我中午饭都没吃，然后紧接着就去中关村准备下午那家的面试</p>
<p>PS:今天还下着雨，挺苦逼的。。。</p>
<p>目测不会发offer，可能是小公司给不起薪资。。。</p>
</blockquote>
<h2 id="NewsDog-公司名字就叫这个薪资标的还挺高"><a href="#NewsDog-公司名字就叫这个薪资标的还挺高" class="headerlink" title="NewsDog(公司名字就叫这个薪资标的还挺高)"></a>NewsDog(公司名字就叫这个薪资标的还挺高)</h2><blockquote>
<p>这家公司是我在拉勾上投的，公司应该是B轮了已经<br>因为是约的是下午两点，而且刚从Melons那里面完就来了，所以去这家公司的时候连中午饭都没吃，让前台给接了杯水暂时压压惊。。。</p>
<p>看简介公司应该是做海外市场主要是信息推荐跟数据挖掘的业务（不知道他们现在的产品是啥）</p>
<p>技术面主要是根据简历去问的，比较在意内存泄漏，内存优化还有View的过渡绘制这一块的东西，还有就是问了问图片开源库Picasso v/s Imageloader v/s Fresco vs Glide 区别以及如何去选择吧，还有eventbus的源码以及注解的优点，其它的大概就是还问了问项目的难点之类的</p>
<p>比较操蛋的是没有讨论薪资，然后就直接送客了，不造差在哪里。。。</p>
</blockquote>
<h2 id="曙光无限"><a href="#曙光无限" class="headerlink" title="曙光无限"></a>曙光无限</h2><p><strong>曙光无限</strong>这家公司是在boss上约的，公司地址在回龙观东大街的腾讯众创空间（办公楼的环境蛮好的），公司主打产品是海外的项目，旗下产品几十种还是蛮多的</p>
<ul>
<li><strong>第一面</strong> ：只是人事先照着简历初略的聊了聊以前的项目经验，由于公司是做海外滤镜软件的，可能对图片算法这块要求蛮高的，福利这块目前是采取接近避税的方式，第一年还不给交住房公积金，貌似还需要第二面总监面，而且还要上机写demo…</li>
<li><strong>目前android行情</strong> ：从以往的面试分析来看基本android的行情接近饱和状态，薪资这块基本稍微要高点的话直接就给你pass然后可能用其它人候选人去对比，市场的行情还真是惨淡</li>
<li><strong>后续</strong> ：没有通知进一步的面试~~~~ HR先面的公司一般都会要求复试各位如果考虑时间成本的话要慎重去这种公司。。。。</li>
</ul>
<hr>
<h2 id="遇见科技"><a href="#遇见科技" class="headerlink" title="遇见科技"></a>遇见科技</h2><p><strong>遇见科技</strong>这家公司是在boss上约的，公司地址在知春路附近，公司的办公环境也还不错哈，项目应该是一款社交软件，貌似起步还是蛮早的，已经做了几年了</p>
<ul>
<li><strong>第一面</strong> ：主要是技术面，问的以简历的内容为主还有面试官会看以往做过的项目（现在看项目的公司确实不多了）比较在意的是之前做过的项目整体的流程，整体架构设计模式还有业务这块的详情，基本都是围绕做的项目这块的技术点来的涉及的知识点也基本涵盖了目前比较流行的开源组件，还有会问一些关于同类框架之前的区别与对比：比如volley与okhttp，图片框架，数据库greenDao，realm，litepal等等性能方面的问题</li>
<li><strong>第二面</strong> ：第一面没什么问题之后会和HR进一步沟通，主要介绍了公司目前的产品方向还有项目节奏，福利待遇神马之类的</li>
<li><strong>总监面</strong> ：能见到总监也基本很不容易了，基本也是聊了聊以往的项目，可能比较看重的是解决问题的能力，会问擅长哪方面（Ui还是业务？）项目难点等等。。。</li>
<li><strong>后续</strong> ：没有通知是否给offer（难道是薪资问题？？现在市场要到20K左右貌似就要考虑考虑了）</li>
</ul>
<hr>
<h2 id="邻动"><a href="#邻动" class="headerlink" title="邻动"></a>邻动</h2><p><strong>邻动</strong> 这家公司是在boss上约的，公司地址也是在知春路附近，公司的办公环境没的说，门口摆着各种零食饮料，面试等待的过程，前台妹子还给了一杯饮料喝O(∩_∩)O~，公司主要做视频方向的项目，目前已知产品叫“快牙”</p>
<ul>
<li><strong>第一面</strong> ：主要是技术面，基本问的跟之前遇到的问题一样，其中回答的不是很好的问题户要是MessageQue的源码实现（我回答错了，应该是链表）还有自定义线程池（应该是问线程池那几个参数），但是公司的技术要求可能希望更倾向于有FFmpeg相关经验还有做过视频剪切，裁剪之类的经验吧，问完就送客了….内心其实还是挺喜欢做视频这块的项目(⊙﹏⊙)b</li>
</ul>
<blockquote>
<p>感觉问到的问题除了那两块其他的回答还是蛮好的，尼玛心累</p>
</blockquote>
<hr>
<h2 id="元宝亿家"><a href="#元宝亿家" class="headerlink" title="元宝亿家"></a>元宝亿家</h2><p><strong>元宝亿家</strong> 这家公司是在boss上约的，公司地址在东直门，去了直接在前台填表，然后一个目测像总监的人直接面试，他们现在的项目是采用MVP写的应该是想找个人快速接手</p>
<ul>
<li><strong>第一面</strong> ：主要是技术面，问的东西感觉还好，但是感觉自己发挥的不是很好，Java String类的底层源码（其实就是char数组），Hashmap实现原理，Android 广播 Service相关的，ANR，gson高级用法（比如序列化的时候如何排除某个字段），项目里用到的设计模式，android手势机制用到了什么设计模式（是责任链模式，这个我回答错了），内存泄漏和内存溢出，子线程不能更新view的机制，Rxjava retrofit okhttp，给我印象比较深的是问了mac上pwd这个命令是干嘛的（我用了这么久mac确实没有用过这个命令，是显示当前文件全路径的）还有用没用过Home brew，最后问了问Git相关的命令pull跟fetch</li>
<li>git rm a.a 移除文件(从暂存区和工作区中删除)</li>
<li><p>git rm –cached a.a 移除文件(只从暂存区中删除)</p>
</li>
<li><p>PS:技术很耐心的给我讲解了我没能答对的问题</p>
</li>
<li><p><strong>总结</strong> ：感觉自己跟目前市场上需求真正意义的Android高级工程职位还是有一定差距的，好多东西还是欠缺好多，还要继续恶补了，fighting…</p>
<blockquote>
<p>约了第二天复试，信心严重受挫，不知道能不能谈拢…<br>复试完结在考虑是否过去…</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="最近面试的几家公司"><a href="#最近面试的几家公司" class="headerlink" title="最近面试的几家公司"></a>最近面试的几家公司</h2><p>这周面的几家公司相对来说都比较正常了没有过多的问源码，基本都是看简历然后以往的项目经验，基本能把以前问过的东西能正确的说出来再面的别的公司也基本OK…</p>
<p><strong>苏宁体育</strong> 这家公司是在boss上约的，公司地址望京锐创国际，去了直接在前台填表，然后有个笔试题（还蛮简单的，主要是写一个单例，多态）,填完就一直等，因为面Android的在排队，然后等了快半个小时，来了两个人面的一个是Android,另外一个是一个女的项目负责人。。。</p>
<ul>
<li><p>总体的面试感觉还OK，因为是做体育类视频项目的，会要求多一些FFmpeg的技能。。。公司会比较在意这一块的想来面试的建议先把这部分摸清，否则人家都不会往深层次的提问，就算问了也接不上哦~</p>
</li>
<li><p>薪资我只奢求不低于之前在信和的待遇，估计按现在的行情很难啊,有种想回原来公司的冲动~~o(&gt;_&lt;)o ~~。。。大的环境冒险离职真的很危险啊，出来都要降薪了，现在这个时间段确实不适合找工作，希望有离职想法的兄弟别冲动….</p>
</li>
</ul>
<p><strong>新娱时代</strong> 这家公司都忘了是哪个大兄弟帮我推的，公司原来是在魏公村，现在搬到了中关村的鼎好电子城写字楼，去的时候还一直在装修，面试的地方极其简陋，因为是内推的技术这块基本就大致聊聊，感觉薪资也是给不到。。而且目前公司还是996的节奏，做海外直播，貌似项目还蛮多的工作强度很大。。。</p>
<ul>
<li>目前他们公司的项目是采用MVP写的，不理解的是为什么项目还用比较陈旧的Volley作为请求框架…</li>
</ul>
<p><strong>半糖</strong> 这家公司是一个非常好的哥们推给他们公司的php的童鞋然后帮我推的，公司在雍和宫的一个胡同里，非常有文艺气息，来到公司首先要填表然后还要填一份性格测试，之后来的面试官也非常的有亲和力，基本都在聊以往互相的项目经验之类的，面试官做Android也蛮久了可能比较保守，自己公司的产品并木有用到最新比较主流的技术框架，应该是考虑项目稳定吧，但是我感觉也太保守了，公司的产品做了三年按他的话来说就是迭代的时间太紧张，基本没有重构的时间就开始做下个版本了，我觉得还是应该搞一搞技术变革的，肯定能提升团队整体的效率，并跟他推荐了一个蛮好用的插件jrebel for android…</p>
<ul>
<li><p>这里安利几个本人一直在用的比较好用库  </p>
</li>
<li><p>下拉刷新&amp;滚动到底部加载更多 <a href="https://github.com/MIkeeJY/demo-1" target="_blank" rel="noopener">https://github.com/MIkeeJY/demo-1</a></p>
</li>
<li><p>这个项目是由一个CSDN大神叫Li Hong修改自PulltoRefresh那个库而来，基本做到了View的分离，用法也比较简单就是直接把拓展的控件放进去，理论上支持所有的View的下拉，需要注意的是这个库只实现了listview的加载更多，recyclerview需要自己拓展</p>
</li>
<li><p><a href="https://github.com/ybq/Endless-RecyclerView" target="_blank" rel="noopener">https://github.com/ybq/Endless-RecyclerView</a> 这个库实现了recyclerview的加载更多配合上面的下拉刷新控件对比别的recyclerview的扩展，这个是代码量最少最简单且bug比较少的，其它类似的扩展大概就是用装饰器模式去封装recyclerview的adapter咯~</p>
</li>
<li><a href="https://github.com/MIkeeJY/OkHttpUtils-2" target="_blank" rel="noopener">https://github.com/MIkeeJY/OkHttpUtils-2</a> 自用Okhttp封装，参考了鸿洋大神Okhttp2.x版本的封装，采用纯Okhttp实现，基本能满足所有的网络请求</li>
<li>Glide封装可以参考 <a href="https://github.com/whyalwaysmea/BigBoom" target="_blank" rel="noopener">https://github.com/whyalwaysmea/BigBoom</a> 这个项目中抽出接口的方式</li>
<li><a href="https://github.com/jinloong/BannerLayout" target="_blank" rel="noopener">https://github.com/jinloong/BannerLayout</a> 虽然star不多但是用起来非常稳定的一个轮播库（比较冷门，相反star数多的库反而各种bug,(⊙﹏⊙)b）</li>
</ul>
<p><strong>总结</strong> ：面试也是一个不断总结跟学习的过程，可能拿到合适的offer还需要一些运气的成份，我始终坚信就算大的环境再不好，但是其实整个行业还是缺牛人的！一时的不景气并不会影响真正技术好的人，博主已经入职了，祝大家好运~</p>
<p><strong>PS</strong> ：首先写这篇文章的目的不在于针对某某公司，这个选择都是双向的，大家谁都不欠谁，只是想把遇到的公司做一个总结展示给大家看，供大家以后求职时候的参考，在于告诫大家如果没什么想不开的千万不要在这个时候离职，比较目前环境可以说是非常的严峻，离职要慎重！！！离职要慎重！！！离职要慎重！！！重要的事情说三遍~！如果有针对某些公司负能量的言语，可能言语过激，希望大家能及时指出，我会及时修改，目测应该还有人对我的技术做出了评价，我也承认目前跟真正的Android高级是有差距的（但是毕竟还是有些技术实力的，15年面过腾讯，优酷，16年面了Apus都拿到了offer，只是我当时想法太年轻没去而已），但是目前Android层的东西还是蛮杂的，我也不可能什么都会，目前已经拿到几家offer也已经做出选择了，这里记录下辛酸的面试历程吧~</p>
<hr>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/11/camera/" itemprop="url">
                  关于调用系统照相机Activity被销毁问题解决
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-11T17:08:26+08:00" content="2016-05-11">
              2016-05-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在项目中需要启用系统照相机来拍照。本来很容易的一个问题。但在适配中出现了问题。<br>简单说一下问题：<br>    有些手机拍照成功，有些手机拍完照后确定返回后activity数据丢失，被销毁了。<br>问题查找：<br>    经过代码查找发现，当这些出问题的手机被调用系统手机拍照时，当前activity被销毁了之后又被重新创建了。即Acitivity 执行了ondestory()–&gt;onCreate()，所以Activity被重新创建了从而内部的数据丢失,而按照正常的逻辑该Activity应该入后台堆栈。一开始以为是系统启用照相机内存不够自动销毁回收。可有些手机不会出现该问题。很无奈。<br>    之后经过本人细心研究activity的生命周期才恍然大悟，原来当手机横竖屏时系统会重新创建一个activity，这就是为什么上个activity会ondestory()–&gt;onCreate()。但为什么有些手机会执行有些不会呢。问题就出在横竖屏上。因为有些手机的系统照相机弄的很炫会自动旋转90度，从而导致了横竖屏的发生（–！看来最潮的也不是好东西，苦了我们这些碼农）。这就是为什有些手机会发生有些不会。跟系统照相机是否旋转有关系。<br>    最后贴上解决方案。<br>    AndroidMainifest.xml中加入</p>
<pre><code>&lt;activity
            android:name=&quot;.Activity&quot;
            android:launchMode=&quot;singleTask&quot;          
            android:configChanges=&quot;orientation|keyboardHidden&quot;                       
            android:theme=&quot;@android:style/Theme.Black.NoTitleBar.Fullscreen&quot;/&gt;
</code></pre><pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) {
    //其实这里什么都不要做
    super.onConfigurationChanged(newConfig);
}
</code></pre><h6 id="PS-在level13以后加入了一个screenSize的属性，这个属性很重要如果在android3-2以后的版本中没有添加”screenSize”的话依然会触发横竖屏activity销毁周期-也就是说不能屏蔽activity销毁，从而调用onConfigurationChanged方法，而在3-2之前只要设置orientation-keyboardHidden就可以-。由于智能机的迅速普及手机的系统大多数升级到4-0以上，这样会导致很多没有设置screenSize属性的程序activity又出现销毁情况。"><a href="#PS-在level13以后加入了一个screenSize的属性，这个属性很重要如果在android3-2以后的版本中没有添加”screenSize”的话依然会触发横竖屏activity销毁周期-也就是说不能屏蔽activity销毁，从而调用onConfigurationChanged方法，而在3-2之前只要设置orientation-keyboardHidden就可以-。由于智能机的迅速普及手机的系统大多数升级到4-0以上，这样会导致很多没有设置screenSize属性的程序activity又出现销毁情况。" class="headerlink" title="PS:在level13以后加入了一个screenSize的属性，这个属性很重要如果在android3.2以后的版本中没有添加”screenSize”的话依然会触发横竖屏activity销毁周期(也就是说不能屏蔽activity销毁，从而调用onConfigurationChanged方法，而在3.2之前只要设置orientation|keyboardHidden就可以)。由于智能机的迅速普及手机的系统大多数升级到4.0以上，这样会导致很多没有设置screenSize属性的程序activity又出现销毁情况。"></a>PS:在level13以后加入了一个screenSize的属性，这个属性很重要如果在android3.2以后的版本中没有添加”screenSize”的话依然会触发横竖屏activity销毁周期(也就是说不能屏蔽activity销毁，从而调用onConfigurationChanged方法，而在3.2之前只要设置orientation|keyboardHidden就可以)。由于智能机的迅速普及手机的系统大多数升级到4.0以上，这样会导致很多没有设置screenSize属性的程序activity又出现销毁情况。</h6><p>试试如下代码：<br>AndroidMainifest.xml中加入</p>
<pre><code>&lt;activity  
  android:name=&quot;.Activity&quot; 
  android:launchMode=&quot;singleTask&quot;    
  android:configChanges=&quot;orientationkeyboardHidden|screenSize&quot;/&gt;
</code></pre><p>复写acitivity的onConfigurationChanged方法</p>
<pre><code>@Override
public void onConfigurationChanged(Configuration newConfig) {
    //其实这里什么都不要做
    super.onConfigurationChanged(newConfig);
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/BaseRecyclerView/" itemprop="url">
                  对RecyclerView.Adapter的简单封装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T14:58:25+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对分页展示而言，RecyclerView已经可以完全替代ListView。这里只进行一下对其Adapter的简单封装。  </p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>目的：目的是为了减少Adapter具体实现的代码，使代码整洁，易于维护。</li>
<li>分析：与listview面向view的adapter不同，recyclerview面向的是viewholder。所以BaseRecyclerAdapter需要两个泛型声明，一个是数据源，一个是viewholder。<br>onCreateViewHoler()方法中需要生成具体的viewhoder实例，所以暂时不去对其做封装。对onBindViewHoler()方法的操作分为两步，一步是bindItemData()将数据填充至itemview，下一步是setupOnItemClick()设置每个item的点击监听。其它方法都是对便利性的扩展，可以根据不同情况添加。</li>
<li>并没有对viewholder动刀子，考虑到目前情况下在AS中利用ButterKnife可以高效的生成viewholder，对开发效率影响不大。不过ButterKnife毕竟是通过运行时反射对view进行绑定的，对效率是有影响，但是AS2.0之后发现Google有扶正DataBindding的趋势，所以综合考虑下，还是没有对viewholder动刀子。但是会在RecyclerView深入研究时思考这个问题。 </li>
</ul>
<h3 id="BaseRecyclerViewAdapter"><a href="#BaseRecyclerViewAdapter" class="headerlink" title="BaseRecyclerViewAdapter"></a>BaseRecyclerViewAdapter</h3><p>话不多说,上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseRecyclerAdapter&lt;T, VH extends RecyclerView.ViewHolder&gt; extends RecyclerView.Adapter&lt;VH&gt; &#123;</span><br><span class="line">    protected List&lt;T&gt; mDatas = new ArrayList&lt;&gt;();</span><br><span class="line">    protected Context mContext;</span><br><span class="line">    protected LayoutInflater inflater;</span><br><span class="line">    AdapterView.OnItemClickListener mItemClickListener;</span><br><span class="line">    public BaseRecyclerAdapter(List&lt;T&gt; mDatas, Context mContext) &#123;</span><br><span class="line">        this.mDatas = mDatas;</span><br><span class="line">        this.mContext = mContext;</span><br><span class="line">        inflater = LayoutInflater.from(mContext);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(VH holder, int position) &#123;</span><br><span class="line">        final T item = getItem(position);</span><br><span class="line">        bindItemData(holder, item, position);</span><br><span class="line">        setupOnItemClick(holder, position);</span><br><span class="line">    &#125;</span><br><span class="line">    protected abstract void bindItemData(VH viewHolder, T data, int position);</span><br><span class="line">    protected void setupOnItemClick(final VH viewHolder, final int position) &#123;</span><br><span class="line">        if (mItemClickListener != null) &#123;</span><br><span class="line">            viewHolder.itemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    mItemClickListener.onItemClick(null, viewHolder.itemView, position, position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return mDatas != null ? mDatas.size() : 0;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getItem(int position) &#123;</span><br><span class="line">        position = Math.max(0, position);</span><br><span class="line">        return mDatas.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;T&gt; getDataSource() &#123;</span><br><span class="line">        return mDatas;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addData(List&lt;T&gt; newItems) &#123;</span><br><span class="line">        if (newItems != null) &#123;</span><br><span class="line">            mDatas.addAll(newItems);</span><br><span class="line">            notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void updateListViewData(List&lt;T&gt; lists) &#123;</span><br><span class="line">        mDatas.clear();</span><br><span class="line">        if (lists != null) &#123;</span><br><span class="line">            mDatas.addAll(lists);</span><br><span class="line">            notifyDataSetChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setOnItemClickListener(AdapterView.OnItemClickListener listener) &#123;</span><br><span class="line">        this.mItemClickListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class NotesAdapter extends BaseRecyclerAdapter&lt;NoteItem, NotesAdapter.NotesViewHolder&gt; &#123;</span><br><span class="line">    public NotesAdapter(List&lt;NoteItem&gt; mDatas, Context mContext) &#123;</span><br><span class="line">        super(mDatas, mContext);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public NotesViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View contentView = LayoutInflater.from(mContext)</span><br><span class="line">                .inflate(R.layout.recycler_item_note, parent, false);</span><br><span class="line">        NotesViewHolder vh = new NotesViewHolder(contentView);</span><br><span class="line">        return vh;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void bindItemData(NotesViewHolder viewHolder, NoteItem data, int position) &#123;</span><br><span class="line">        viewHolder.titleTxt.setText(data.getTitle());</span><br><span class="line">        viewHolder.timeTxt.setText(data.getCreatedTime());</span><br><span class="line">        viewHolder.tagTxt.setText(data.getTags().size() != 0 ? data.getTags().get(0) : &quot;other&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static class NotesViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        @Bind(R.id.title_txt)</span><br><span class="line">        TextView titleTxt;</span><br><span class="line">        @Bind(R.id.time_txt)</span><br><span class="line">        TextView timeTxt;</span><br><span class="line">        @Bind(R.id.tag_txt)</span><br><span class="line">        TextView tagTxt;</span><br><span class="line">        NotesViewHolder(View view) &#123;</span><br><span class="line">            super(view);</span><br><span class="line">            ButterKnife.bind(this, view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/gson/" itemprop="url">
                  Gson解析（List和Map）格式json数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T14:58:25+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时候服务端非得返回比较傻逼的Json</p>
<h2 id="这时候可以用gson解析带有键值对的json"><a href="#这时候可以用gson解析带有键值对的json" class="headerlink" title="这时候可以用gson解析带有键值对的json"></a>这时候可以用gson解析带有键值对的json</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class jsonParse&#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">class City&#123;</span><br><span class="line"></span><br><span class="line">        int id;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        String code;</span><br><span class="line"></span><br><span class="line">        String map;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //列表/array 数据</span><br><span class="line"></span><br><span class="line">                 String str=<span class="string">"[&#123;'id': '1','code': 'bj','name': '北京','map': '39.90403, 116.40752599999996'&#125;, &#123;'id': '2','code': 'sz','name': '深圳','map': '22.543099, 114.05786799999998'&#125;, &#123;'id': '9','code': 'sh','name': '上海','map': '31.230393,121.473704'&#125;, &#123;'id': '10','code': 'gz','name': '广州','map': '23.129163,113.26443500000005'&#125;]"</span>;</span><br><span class="line"></span><br><span class="line">        Gson gson=new Gson();</span><br><span class="line"></span><br><span class="line">        List&lt;City&gt; rs=new ArrayList&lt;City&gt;();</span><br><span class="line"></span><br><span class="line">         Type <span class="built_in">type</span> = new TypeToken&lt;ArrayList&lt;City&gt;&gt;() &#123;&#125;.getType();</span><br><span class="line"></span><br><span class="line">          rs=gson.fromJson(str, <span class="built_in">type</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(City o:rs)&#123;</span><br><span class="line"></span><br><span class="line">                  System.out.println(o.name);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">          //map数据</span><br><span class="line"></span><br><span class="line">          String jsonStr=<span class="string">"&#123;'1': &#123;'id': '1','code': 'bj','name': '北京','map': '39.90403, 116.40752599999996'&#125;,'2': &#123;'id': '2','code': 'sz','name': '深圳','map': '22.543099, 114.05786799999998'&#125;,'9': &#123;'id': '9','code': 'sh','name': '上海','map': '31.230393,121.473704'&#125;,'10': &#123;'id': '10','code': 'gz','name': '广州','map': '23.129163,113.26443500000005'&#125;&#125;"</span>;</span><br><span class="line"></span><br><span class="line">          Map&lt;String, City&gt; citys = gson.fromJson(jsonStr, new TypeToken&lt;Map&lt;String, City&gt;&gt;() &#123;&#125;.getType()); </span><br><span class="line"></span><br><span class="line">          System.out.println(citys.get(<span class="string">"1"</span>).name+<span class="string">"----------"</span>+citys.get(<span class="string">"2"</span>).code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/gsonUtil/" itemprop="url">
                  Gson工具类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T14:58:25+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用泛型来封装Gson</p>
<h2 id="泛型才是JAVA的精髓"><a href="#泛型才是JAVA的精髓" class="headerlink" title="泛型才是JAVA的精髓"></a>泛型才是JAVA的精髓</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">import com.google.gson.Gson;</span><br><span class="line">import com.google.gson.JsonArray;</span><br><span class="line">import com.google.gson.JsonElement;</span><br><span class="line">import com.google.gson.JsonParser;</span><br><span class="line">import com.google.gson.reflect.TypeToken;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class GsonUtil &#123;</span><br><span class="line">    private static Gson gson = null;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        <span class="keyword">if</span> (gson == null) &#123;</span><br><span class="line">            gson = new Gson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">GsonUtil</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转成json</span><br><span class="line">     *</span><br><span class="line">     * @param object</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static String GsonString(Object object) &#123;</span><br><span class="line">        String gsonString = null;</span><br><span class="line">        <span class="keyword">if</span> (gson != null) &#123;</span><br><span class="line">            gsonString = gson.toJson(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> gsonString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转成bean</span><br><span class="line">     *</span><br><span class="line">     * @param gsonString</span><br><span class="line">     * @param cls</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; T GsonToBean(String gsonString, Class&lt;T&gt; cls) &#123;</span><br><span class="line">        T t = null;</span><br><span class="line">        <span class="keyword">if</span> (gson != null) &#123;</span><br><span class="line">            t = gson.fromJson(gsonString, cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转成list</span><br><span class="line">     * 解决泛型问题</span><br><span class="line">     *</span><br><span class="line">     * @param json</span><br><span class="line">     * @param cls</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; GsonToList(String json, Class&lt;T&gt; cls) &#123;</span><br><span class="line">        Gson gson = new Gson();</span><br><span class="line">        List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br><span class="line">        JsonArray array = new JsonParser().parse(json).getAsJsonArray();</span><br><span class="line">        <span class="keyword">for</span> (final JsonElement elem : array) &#123;</span><br><span class="line">            list.add(gson.fromJson(elem, cls));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转成list中有map的</span><br><span class="line">     *</span><br><span class="line">     * @param gsonString</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; List&lt;Map&lt;String, T&gt;&gt; GsonToListMaps(String gsonString) &#123;</span><br><span class="line">        List&lt;Map&lt;String, T&gt;&gt; list = null;</span><br><span class="line">        <span class="keyword">if</span> (gson != null) &#123;</span><br><span class="line">            list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;Map&lt;String, T&gt;&gt;&gt;() &#123;</span><br><span class="line">            &#125;.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 转成map的</span><br><span class="line">     *</span><br><span class="line">     * @param gsonString</span><br><span class="line">     * @<span class="built_in">return</span></span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; Map&lt;String, T&gt; GsonToMaps(String gsonString) &#123;</span><br><span class="line">        Map&lt;String, T&gt; map = null;</span><br><span class="line">        <span class="keyword">if</span> (gson != null) &#123;</span><br><span class="line">            map = gson.fromJson(gsonString, new TypeToken&lt;Map&lt;String, T&gt;&gt;() &#123;</span><br><span class="line">            &#125;.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * 将Map转化为Json</span><br><span class="line">     *</span><br><span class="line">     * @param map</span><br><span class="line">     * @<span class="built_in">return</span> String</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; String mapToJson(Map&lt;String, T&gt; map) &#123;</span><br><span class="line">        String jsonStr = null;</span><br><span class="line">        <span class="keyword">if</span> (gson != null) &#123;</span><br><span class="line">            jsonStr = gson.toJson(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> jsonStr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/default_avatar.jpg" alt="Mikee">
          <p class="site-author-name" itemprop="name">Mikee</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mikee</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
